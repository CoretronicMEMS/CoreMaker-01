From 90a1414b385a47144c6a4669679ae9a509e8e319 Mon Sep 17 00:00:00 2001
From: "jeff.cheng" <jeff.cheng@coretronic.com>
Date: Fri, 3 Dec 2021 15:58:15 +0800
Subject: [PATCH] Add OPL1000 driver.

---
 connectivity/drivers/wifi/CMakeLists.txt      |    2 +
 .../wifi/opl1000-driver/CMakeLists.txt        |   14 +
 .../wifi/opl1000-driver/OPL1000/OPL1000.cpp   | 1145 +++++++++++++++++
 .../wifi/opl1000-driver/OPL1000/OPL1000.h     |  491 +++++++
 .../wifi/opl1000-driver/OPL1000Interface.cpp  | 1091 ++++++++++++++++
 .../wifi/opl1000-driver/OPL1000Interface.h    |  548 ++++++++
 .../drivers/wifi/opl1000-driver/mbed_lib.json |  108 ++
 connectivity/netsocket/CMakeLists.txt         |    1 +
 8 files changed, 3400 insertions(+)
 create mode 100644 connectivity/drivers/wifi/opl1000-driver/CMakeLists.txt
 create mode 100644 connectivity/drivers/wifi/opl1000-driver/OPL1000/OPL1000.cpp
 create mode 100644 connectivity/drivers/wifi/opl1000-driver/OPL1000/OPL1000.h
 create mode 100644 connectivity/drivers/wifi/opl1000-driver/OPL1000Interface.cpp
 create mode 100644 connectivity/drivers/wifi/opl1000-driver/OPL1000Interface.h
 create mode 100644 connectivity/drivers/wifi/opl1000-driver/mbed_lib.json

diff --git a/connectivity/drivers/wifi/CMakeLists.txt b/connectivity/drivers/wifi/CMakeLists.txt
index 6ca3b2f092..d260ce8efe 100644
--- a/connectivity/drivers/wifi/CMakeLists.txt
+++ b/connectivity/drivers/wifi/CMakeLists.txt
@@ -7,6 +7,8 @@ add_subdirectory(COMPONENT_WHD EXCLUDE_FROM_ALL)
 
 add_subdirectory(esp8266-driver)
 
+add_subdirectory(opl1000-driver)
+
 target_link_libraries(mbed-wifi
     INTERFACE
         mbed-netsocket
diff --git a/connectivity/drivers/wifi/opl1000-driver/CMakeLists.txt b/connectivity/drivers/wifi/opl1000-driver/CMakeLists.txt
new file mode 100644
index 0000000000..3ad951e7af
--- /dev/null
+++ b/connectivity/drivers/wifi/opl1000-driver/CMakeLists.txt
@@ -0,0 +1,14 @@
+# Copyright (c) 2020 ARM Limited. All rights reserved.
+# SPDX-License-Identifier: Apache-2.0
+
+target_sources(mbed-wifi
+    INTERFACE
+        OPL1000Interface.cpp
+        OPL1000/OPL1000.cpp
+)
+
+target_include_directories(mbed-wifi
+    INTERFACE
+        .
+        ./OPL1000
+)
diff --git a/connectivity/drivers/wifi/opl1000-driver/OPL1000/OPL1000.cpp b/connectivity/drivers/wifi/opl1000-driver/OPL1000/OPL1000.cpp
new file mode 100644
index 0000000000..eb783fed7b
--- /dev/null
+++ b/connectivity/drivers/wifi/opl1000-driver/OPL1000/OPL1000.cpp
@@ -0,0 +1,1145 @@
+/* OPL1000 Example refrerence from esp8266-driver.
+ */
+#define MBED_CONF_CMDLINE_ENABLE_INTERNAL_TRACES 1
+#if DEVICE_SERIAL && DEVICE_INTERRUPTIN &&                                   \
+    defined(MBED_CONF_EVENTS_PRESENT) && defined(MBED_CONF_NSAPI_PRESENT) && \
+    defined(MBED_CONF_RTOS_API_PRESENT)
+#ifndef __STDC_FORMAT_MACROS
+#define __STDC_FORMAT_MACROS
+#endif
+#include "OPL1000.h"
+
+#include <inttypes.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "PinNames.h"
+#include "mbed_trace.h"
+#include "netsocket/nsapi_types.h"
+#include "platform/Callback.h"
+#include "platform/mbed_error.h"
+#include "rtos/Kernel.h"
+
+#define TRACE_GROUP "OPLA"  // OPL1000 AT layer
+
+#define OPL1000_ALL_SOCKET_IDS -1
+
+#define OPL1000_DEFAULT_SERIAL_BAUDRATE 115200
+
+using namespace mbed;
+using namespace std::chrono;
+using std::milli;
+
+OPL1000::OPL1000(PinName tx, PinName rx, bool debug, PinName rts, PinName cts)
+    : _sdk_v(-1),
+      _at_v(-1, -1),
+      _callback(),
+      _serial(tx, rx, MBED_CONF_OPL1000_SERIAL_BAUDRATE),
+      _serial_rts(rts),
+      _serial_cts(cts),
+      _parser(&_serial),
+      _packets(0),
+      _packets_end(&_packets),
+      _sock_active_id(-1),
+      _heap_usage(0),
+      _connect_error(0),
+      _disconnect(false),
+      _fail(false),
+      _sock_already(false),
+      _closed(false),
+      _error(false),
+      _busy(false),
+      _reset_done(false),
+      _sock_sending_id(-1),
+      _conn_status(NSAPI_STATUS_DISCONNECTED) {
+  _serial.set_baud(OPL1000_DEFAULT_SERIAL_BAUDRATE);
+  _parser.debug_on(debug);
+  _parser.set_delimiter("\r\n");
+  _parser.oob("+IPD", callback(this, &OPL1000::_oob_packet_hdlr));
+  // Note: espressif at command document says that this should be
+  // +CWJAP_CUR:<error code> but seems that at least current version is not
+  // sending it
+  // https://www.espressif.com/sites/default/files/documentation/4a-esp8266_at_instruction_set_en.pdf
+  // Also seems that ERROR is not sent, but FAIL instead
+  _parser.oob("0,CLOSED", callback(this, &OPL1000::_oob_socket0_closed));
+  _parser.oob("1,CLOSED", callback(this, &OPL1000::_oob_socket1_closed));
+  _parser.oob("2,CLOSED", callback(this, &OPL1000::_oob_socket2_closed));
+  _parser.oob("3,CLOSED", callback(this, &OPL1000::_oob_socket3_closed));
+  _parser.oob("4,CLOSED", callback(this, &OPL1000::_oob_socket4_closed));
+  // _parser.oob("+CWJAP:", callback(this, &OPL1000::_oob_connect_err));
+  _parser.oob("WIFI ", callback(this, &OPL1000::_oob_connection_status));
+  _parser.oob("UNLINK", callback(this, &OPL1000::_oob_socket_close_err));
+  _parser.oob("ALREADY CONNECTED", callback(this, &OPL1000::_oob_conn_already));
+  _parser.oob("ERROR", callback(this, &OPL1000::_oob_err));
+  _parser.oob("ready", callback(this, &OPL1000::_oob_ready));
+  //_parser.oob("+CWLAP:", callback(this, &OPL1000::_oob_scan_results));
+  // Don't expect to find anything about the watchdog reset in official
+  // documentation
+  // https://techtutorialsx.com/2017/01/21/esp8266-watchdog-functions/
+  _parser.oob("wdt reset", callback(this, &OPL1000::_oob_watchdog_reset));
+  // Don't see a reason to make distiction between software(Software WDT reset)
+  // and hardware(wdt reset) watchdog treatment
+  // https://github.com/esp8266/Arduino/blob/4897e0006b5b0123a2fa31f67b14a3fff65ce561/doc/faq/a02-my-esp-crashes.md#watchdog
+  _parser.oob("Soft WDT reset", callback(this, &OPL1000::_oob_watchdog_reset));
+  _parser.oob("busy ", callback(this, &OPL1000::_oob_busy));
+  // NOTE: documentation v3.0 says '+CIPRECVDATA:<data_len>,' but it's not how
+  // the FW responds...
+  _parser.oob("+CIPRECVDATA,", callback(this, &OPL1000::_oob_tcp_data_hdlr));
+  // Register 'SEND OK'/'SEND FAIL' oobs here. Don't get involved in oob
+  // management with send status because ESP8266 modem possibly doesn't reply
+  // these packets on error case.
+  _parser.oob("SEND OK", callback(this, &OPL1000::_oob_send_ok_received));
+  _parser.oob("SEND FAIL", callback(this, &OPL1000::_oob_send_fail_received));
+
+  for (int i = 0; i < SOCKET_COUNT; i++) {
+    _sock_i[i].open = false;
+    _sock_i[i].proto = NSAPI_UDP;
+    _sock_i[i].tcp_data = NULL;
+    _sock_i[i].tcp_data_avbl = 0;
+    _sock_i[i].tcp_data_rcvd = 0;
+    _sock_i[i].send_fail = false;
+  }
+
+  _scan_r.res = NULL;
+  _scan_r.limit = 0;
+  _scan_r.cnt = 0;
+}
+
+bool OPL1000::at_available() {
+  bool ready = false;
+
+  _smutex.lock();
+  // Might take a while to respond after HW reset
+  for (int i = 0; i < 5; i++) {
+    ready = _parser.send("AT") && _parser.recv("OK\n");
+    if (ready) {
+      break;
+    }
+    tr_debug("at_available(): Waiting AT response.");
+  }
+  // Switch baud-rate from default one to assigned one
+  if (MBED_CONF_OPL1000_SERIAL_BAUDRATE != OPL1000_DEFAULT_SERIAL_BAUDRATE) {
+    ready &= _parser.send("AT+UART_CUR=%u,8,1,0,0",
+                          MBED_CONF_OPL1000_SERIAL_BAUDRATE) &&
+             _parser.recv("OK\n");
+    _serial.set_baud(MBED_CONF_OPL1000_SERIAL_BAUDRATE);
+    ready &= _parser.send("AT") && _parser.recv("OK\n");
+  }
+  _smutex.unlock();
+
+  return ready;
+}
+
+bool OPL1000::echo_off() {
+  _smutex.lock();
+  bool ready = _parser.send("ATE0") && _parser.recv("OK\n");
+  _smutex.unlock();
+
+  return ready;
+}
+
+int OPL1000::sdk_version() {
+  int version;
+
+  _smutex.lock();
+  bool done = _parser.send("AT+GMR") &&
+              _parser.recv("SDK version:%d", &version) && _parser.recv("OK\n");
+  _smutex.unlock();
+
+  if (!done) {
+    return -1;
+  }
+  return version;
+}
+
+struct OPL1000::fw_at_version OPL1000::at_version() {
+  int major;
+  int minor;
+
+  _smutex.lock();
+  bool done = _parser.send("AT+GMR") &&
+              _parser.recv("AT version:%d.%d", &major, &minor) &&
+              _parser.recv("OK\n");
+  _smutex.unlock();
+
+  if (done) {
+    _at_v.major = major;
+    _at_v.minor = minor;
+  }
+  return _at_v;
+}
+
+bool OPL1000::stop_uart_hw_flow_ctrl(void) {
+  bool done = true;
+#if DEVICE_SERIAL_FC
+
+  if (_serial_rts != NC || _serial_cts != NC) {
+    // Stop board's flow control
+    _serial.set_flow_control(SerialBase::Disabled, _serial_rts, _serial_cts);
+
+    // Stop OPL1000's flow control
+    done = _parser.send("AT+UART_CUR=%u,8,1,0,0",
+                        MBED_CONF_OPL1000_SERIAL_BAUDRATE) &&
+           _parser.recv("OK\n");
+  }
+
+#endif
+  return done;
+}
+
+bool OPL1000::start_uart_hw_flow_ctrl(void) {
+  bool done = true;
+
+#if DEVICE_SERIAL_FC
+  _smutex.lock();
+  if (_serial_rts != NC && _serial_cts != NC) {
+    // Start OPL1000's flow control
+    done = _parser.send("AT+UART_CUR=%u,8,1,0,3",
+                        MBED_CONF_OPL1000_SERIAL_BAUDRATE) &&
+           _parser.recv("OK\n");
+
+    if (done) {
+      // Start board's flow control
+      _serial.set_flow_control(SerialBase::RTSCTS, _serial_rts, _serial_cts);
+    }
+
+  } else if (_serial_rts != NC) {
+    _serial.set_flow_control(SerialBase::RTS, _serial_rts, NC);
+
+    // Enable OPL1000's CTS pin
+    done = _parser.send("AT+UART_CUR=%u,8,1,0,2",
+                        MBED_CONF_OPL1000_SERIAL_BAUDRATE);
+  } else if (_serial_cts != NC) {
+    // Enable OPL1000's RTS pin
+    done = _parser.send("AT+UART_CUR=%u,8,1,0,1",
+                        MBED_CONF_OPL1000_SERIAL_BAUDRATE);
+
+    if (done) {
+      _serial.set_flow_control(SerialBase::CTS, NC, _serial_cts);
+    }
+  }
+  _smutex.unlock();
+
+  if (!done) {
+    tr_debug("start_uart_hw_flow_ctrl(): Enable UART HW flow control: FAIL.");
+  }
+#else
+  if (_serial_rts != NC || _serial_cts != NC) {
+    done = false;
+  }
+#endif
+  return done;
+}
+
+bool OPL1000::startup() {
+  _smutex.lock();
+  set_timeout(OPL1000_CONNECT_TIMEOUT);
+  bool done = _parser.send("AT+CIPMUX=1") && _parser.recv("OK\n");
+  set_timeout();  // Restore default
+  _smutex.unlock();
+
+  return done;
+}
+
+bool OPL1000::reset(void) {
+  static const auto OPL1000_BOOTTIME = 10s;
+  bool done = false;
+
+  _smutex.lock();
+
+  auto start_time = rtos::Kernel::Clock::now();
+  _reset_done = false;
+  set_timeout(OPL1000_RECV_TIMEOUT);
+  for (int i = 0; i < 2; i++) {
+    done = _parser.send("AT+RST") && _parser.recv("OK\n");
+    if (!done) {
+      continue;
+    }
+    while (done) {
+      if (rtos::Kernel::Clock::now() - start_time >= OPL1000_BOOTTIME) {
+        _reset_done = true;
+        break;
+      }
+      rtos::ThisThread::sleep_for(100ms);
+    }
+    if (_reset_done) {
+      break;
+    }
+  }
+  tr_debug("reset(): Done: %s.", done ? "OK" : "FAIL");
+
+  _clear_socket_packets(OPL1000_ALL_SOCKET_IDS);
+  _sock_sending_id = -1;
+  set_timeout();
+  _smutex.unlock();
+
+  return done;
+}
+
+nsapi_error_t OPL1000::connect(const char *ap, const char *passPhrase) {
+  nsapi_error_t ret = NSAPI_ERROR_OK;
+
+  _smutex.lock();
+  set_timeout(OPL1000_RECV_TIMEOUT);
+  if (_conn_status != NSAPI_STATUS_CONNECTING) {
+    _parser.send("AT+CWLAP") &&
+        _parser.recv("OK\n");  // OPL1000 AT command is wrong, get timeout
+                               // (OPL1000_RECV_TIMEOUT).
+    _parser.send("AT+CWJAP=\"%s\",\"%s\"", ap, passPhrase) &&
+        _parser.recv("OK\n");  // OPL1000 AT command is wrong, get
+                               // timeout(OPL1000_RECV_TIMEOUT).
+    bool res = _parser.send("AT+CWJAP?") && _parser.recv("No AP connected\n");
+    if (res) {
+      ret = NSAPI_ERROR_AUTH_FAILURE;
+      _conn_status = NSAPI_STATUS_DISCONNECTED;
+    } else {
+      ret = NSAPI_ERROR_IS_CONNECTED;
+      _conn_status = NSAPI_STATUS_CONNECTING;
+    }
+    _conn_stat_cb();
+  }
+  set_timeout();
+  _smutex.unlock();
+
+  return ret;
+}
+
+bool OPL1000::disconnect(void) {
+  _smutex.lock();
+  _disconnect = true;
+  rtos::ThisThread::sleep_for(1000);  // Wait for socket close finished.
+  bool done = _parser.send("AT+CWQAP") && _parser.recv("OK\n");
+  _conn_status = NSAPI_STATUS_DISCONNECTED;
+  _conn_stat_cb();
+
+  _smutex.unlock();
+
+  return done;
+}
+
+bool OPL1000::ip_info_print(int enable) {
+  _smutex.lock();
+  _disconnect = true;
+  bool done = _parser.send("AT+CIPDINFO=%d", enable) && _parser.recv("OK\n");
+  _smutex.unlock();
+
+  return done;
+}
+
+const char *OPL1000::ip_addr(void) {
+  _smutex.lock();
+  set_timeout(OPL1000_CONNECT_TIMEOUT);
+  if (!(_parser.send("AT+CIFSR") &&
+        _parser.recv("+CIFSR:STAIP,\"%15[^\"]\"", _ip_buffer) &&
+        _parser.recv("OK\n"))) {
+    _smutex.unlock();
+    return 0;
+  }
+  set_timeout();
+  _smutex.unlock();
+
+  return _ip_buffer;
+}
+
+bool OPL1000::set_ip_addr(const char *ip, const char *gateway,
+                          const char *netmask) {  // Not Supported
+  return false;
+}
+
+const char *OPL1000::mac_addr(void) {
+  _smutex.lock();
+  if (!(_parser.send("AT+CIFSR") &&
+        _parser.recv("+CIFSR:STAMAC,\"%17[^\"]\"", _mac_buffer) &&
+        _parser.recv("OK\n"))) {
+    _smutex.unlock();
+    return 0;
+  }
+  _smutex.unlock();
+
+  return _mac_buffer;
+}
+
+nsapi_error_t OPL1000::open_udp(int id, const char *addr, int port,
+                                int local_port, int udp_mode) {
+  static const char *type = "UDP";
+  bool done = false;
+
+  ip_info_print(1);
+
+  _smutex.lock();
+
+  // process OOB so that _sock_i reflects the correct state of the socket
+  _process_oob(OPL1000_SEND_TIMEOUT, true);
+
+  // Previous close() can fail with busy in sending. Usually, user will ignore
+  // the close() error code and cause 'spurious close', in which case user has
+  // closed the socket but ESP8266 modem hasn't yet. Because we don't know how
+  // long ESP8266 modem will trap in busy, enlarge retry count or timeout in
+  // close() isn't a nice way. Here, we actively re-call close() in open() to
+  // let the modem close the socket. User can re-try open() on failure.
+  // Without this active close(), open() can fail forever with previous
+  // 'spurious close', unless peer closes the socket and so ESP8266 modem
+  // closes it accordingly.
+  if (id >= SOCKET_COUNT) {
+    _smutex.unlock();
+    return NSAPI_ERROR_PARAMETER;
+  } else if (_sock_i[id].open) {
+    close(id);
+  }
+
+  for (int i = 0; i < 2; i++) {
+    if (!(_parser.send("AT+CIPMUX=1") && _parser.recv("OK\n"))) {
+      continue;
+    }
+    rtos::ThisThread::sleep_for(1000ms);  // OPL1000 need delay 1 sec.
+    if (local_port) {
+      done = _parser.send("AT+CIPSTART=%d,\"%s\",\"%s\",%d,%d,%d", id, type,
+                          addr, port, local_port, udp_mode);
+    } else {
+      done =
+          _parser.send("AT+CIPSTART=%d,\"%s\",\"%s\",%d", id, type, addr, port);
+    }
+    if (done) {
+      if (!_parser.recv("%d,CONNECT", &id)) {
+        printf("Cannot connect to udp ...\n");
+        done = false;
+        continue;
+      } else {
+        _sock_i[id].open = true;
+        _sock_i[id].proto = NSAPI_UDP;
+      }
+      break;
+    }
+  }
+  _clear_socket_packets(id);
+
+  _smutex.unlock();
+
+  tr_debug("open_udp(): UDP socket %d opened: %s.", id,
+           (_sock_i[id].open ? "true" : "false"));
+  return done ? NSAPI_ERROR_OK : NSAPI_ERROR_DEVICE_ERROR;
+}
+
+nsapi_error_t OPL1000::open_tcp(int id, const char *addr, int port,
+                                int keepalive) {
+  static const char *type = "TCP";
+  bool done = false;
+
+  ip_info_print(1);
+
+  if (!addr) {
+    return NSAPI_ERROR_PARAMETER;
+  }
+  _smutex.lock();
+
+  // process OOB so that _sock_i reflects the correct state of the socket
+  _process_oob(OPL1000_SEND_TIMEOUT, true);
+
+  // See the reason above with close()
+  if (id >= SOCKET_COUNT) {
+    _smutex.unlock();
+    return NSAPI_ERROR_PARAMETER;
+  } else if (_sock_i[id].open) {
+    close(id);
+  }
+
+  for (int i = 0; i < 2; i++) {
+    if (!(_parser.send("AT+CIPMUX=1") && _parser.recv("OK\n"))) {
+      continue;
+    }
+    rtos::ThisThread::sleep_for(1000ms);  // OPL1000 need delay 1 sec.
+
+    printf("AT+CIPSTART=%d,\"%s\",\"%s\",%d\n", id, type, addr, port);
+    done =
+        _parser.send("AT+CIPSTART=%d,\"%s\",\"%s\",%d", id, type, addr, port);
+    if (done) {
+      if (!_parser.recv("%d,CONNECT", &id)) {
+        printf("Cannot connect to tcp server...\n");
+        done = false;
+        continue;
+      } else {
+        _sock_i[id].open = true;
+        _sock_i[id].proto = NSAPI_TCP;
+      }
+      break;
+    }
+  }
+  _clear_socket_packets(id);
+
+  _smutex.unlock();
+
+  tr_debug("open_tcp: TCP socket %d opened: %s . ", id,
+           (_sock_i[id].open ? "true" : "false"));
+
+  return done ? NSAPI_ERROR_OK : NSAPI_ERROR_DEVICE_ERROR;
+}
+
+bool OPL1000::dns_lookup(const char *name, char *ip) {
+  _smutex.lock();
+  set_timeout(OPL1000_DNS_TIMEOUT);
+  bool done = _parser.send("AT+CIPDOMAIN=\"%s\"", name) &&
+              _parser.recv("+CIPDOMAIN:%15[^\n]\n", ip) && _parser.recv("OK\n");
+  set_timeout();
+  _smutex.unlock();
+
+  return done;
+}
+
+nsapi_size_or_error_t OPL1000::send(int id, const void *data, uint32_t amount) {
+  if (_sock_i[id].proto == NSAPI_TCP) {
+    if (_sock_sending_id >= 0 && _sock_sending_id < SOCKET_COUNT) {
+      if (!_sock_i[id].send_fail) {
+        tr_debug(
+            "send(): Previous packet (socket %d) was not yet ACK-ed with "
+            "SEND "
+            "OK.",
+            _sock_sending_id);
+        return NSAPI_ERROR_WOULD_BLOCK;
+      } else {
+        tr_debug("send(): Previous packet (socket %d) failed.", id);
+        return NSAPI_ERROR_DEVICE_ERROR;
+      }
+    }
+  }
+
+  nsapi_error_t ret = NSAPI_ERROR_DEVICE_ERROR;
+  int bytes_confirmed = 0;
+
+  // +CIPSEND supports up to 2048 bytes at a time
+  // Data stream can be truncated
+  if (amount > 2048 && _sock_i[id].proto == NSAPI_TCP) {
+    amount = 2048;
+    // Datagram must stay intact
+  } else if (amount > 2048 && _sock_i[id].proto == NSAPI_UDP) {
+    tr_debug("send(): UDP datagram maximum size is 2048 .");
+    return NSAPI_ERROR_PARAMETER;
+  }
+
+  _smutex.lock();
+  // Mark this socket is sending. We allow only one actively sending socket
+  // because:
+  // 1. OPL1000 AT packets 'SEND OK'/'SEND FAIL' are not associated with
+  // socket ID. No way to tell them.
+  // 2. In original implementation, OPL1000::send() is synchronous, which
+  // implies only one actively sending socket.
+  _sock_sending_id = id;
+  set_timeout(OPL1000_SEND_TIMEOUT);
+  _busy = false;
+  _error = false;
+  if (!_parser.send("AT+CIPSEND=%d,%d", id, amount)) {
+    tr_debug("send(): AT+CIPSEND failed.");
+    goto END;
+  }
+  rtos::ThisThread::sleep_for(10);
+  if (!_parser.recv(">")) {
+    // This means OPL1000 hasn't even started to receive data
+    tr_debug("send(): Didn't get \">\"");
+    if (_sock_i[id].proto == NSAPI_TCP) {
+      ret = NSAPI_ERROR_WOULD_BLOCK;  // Not necessarily critical error.
+    } else if (_sock_i[id].proto == NSAPI_UDP) {
+      ret = NSAPI_ERROR_NO_MEMORY;
+    }
+    goto END;
+  }
+  if (_parser.write((char *)data, (int)amount) < 0) {
+    tr_debug("send(): Failed to write serial data");
+    // Serial is not working, serious error, reset needed.
+    ret = NSAPI_ERROR_DEVICE_ERROR;
+    goto END;
+  }
+
+  // The "Recv X bytes" is not documented.
+  if (!_parser.recv("Recv %d bytes", &bytes_confirmed)) {
+    tr_debug("send(): Bytes not confirmed.");
+    if (_sock_i[id].proto == NSAPI_TCP) {
+      ret = NSAPI_ERROR_WOULD_BLOCK;
+    } else if (_sock_i[id].proto == NSAPI_UDP) {
+      ret = NSAPI_ERROR_NO_MEMORY;
+    }
+  } else if (bytes_confirmed != (int)amount && _sock_i[id].proto == NSAPI_UDP) {
+    tr_debug("send(): Error: confirmed %d bytes, but expected %d.",
+             bytes_confirmed, amount);
+    ret = NSAPI_ERROR_DEVICE_ERROR;
+  } else {
+    // TCP can accept partial writes(if they ever happen)
+    ret = bytes_confirmed;
+  }
+
+END:
+  _process_oob(OPL1000_RECV_TIMEOUT,
+               true);  // Drain USART receive register to avoid data overrun
+
+  // error hierarchy, from low to high
+  // NOTE: We cannot return NSAPI_ERROR_WOULD_BLOCK when "Recv X bytes" has
+  // reached, otherwise duplicate data send.
+  if (_busy && ret < 0) {
+    ret = NSAPI_ERROR_WOULD_BLOCK;
+    tr_debug("send(): Modem busy.");
+  }
+
+  if (_error) {
+    // FIXME: Not sure clear or not of _error. See it as device error and it
+    // can recover only via reset?
+    _sock_sending_id = -1;
+    ret = NSAPI_ERROR_CONNECTION_LOST;
+    tr_debug("send(): Connection disrupted.");
+  }
+
+  if (_sock_i[id].send_fail) {
+    _sock_sending_id = -1;
+    if (_sock_i[id].proto == NSAPI_TCP) {
+      ret = NSAPI_ERROR_DEVICE_ERROR;
+    } else {
+      ret = NSAPI_ERROR_NO_MEMORY;
+    }
+    tr_debug("send(): SEND FAIL received.");
+  }
+
+  if (!_sock_i[id].open && ret < 0) {
+    _sock_sending_id = -1;
+    ret = NSAPI_ERROR_CONNECTION_LOST;
+    tr_debug("send(): Socket %d closed abruptly.", id);
+  }
+
+  set_timeout();
+  _smutex.unlock();
+  return ret;
+}
+
+void OPL1000::_oob_packet_hdlr() {
+  int id;
+  int port;
+  int amount;
+  int pdu_len;
+
+  // Get socket id
+  if (!_parser.scanf(",%d,", &id)) {
+    return;
+  }
+
+  if (_tcp_passive && _sock_i[id].open == true &&
+      _sock_i[id].proto == NSAPI_TCP) {
+    // For TCP +IPD return only id and amount and it is independent on
+    // AT+CIPDINFO settings Unfortunately no information about that in ESP
+    // manual but it has sense.
+    if (_parser.recv("%d\n", &amount)) {
+      _sock_i[id].tcp_data_avbl = amount;
+
+      // notify data is available
+      if (_callback) {
+        _callback();
+      }
+    }
+    return;
+  } else {
+    if (!(_parser.scanf("%d,", &amount) &&
+          _parser.scanf("%15[^,],", _ip_buffer) &&
+          _parser.scanf("%d:", &port))) {
+      return;
+    }
+  }
+
+  pdu_len = sizeof(struct packet) + amount;
+
+  if ((_heap_usage + pdu_len) > MBED_CONF_OPL1000_SOCKET_BUFSIZE) {
+    tr_debug("\"opl1000.socket-bufsize\"-limit exceeded, packet dropped");
+    return;
+  }
+
+  struct packet *packet = (struct packet *)malloc(pdu_len);
+  if (!packet) {
+    tr_debug(
+        "_oob_packet_hdlr(): Out of memory, unable to allocate memory for "
+        "packet.");
+    return;
+  }
+  _heap_usage += pdu_len;
+
+  packet->id = id;
+  if (_sock_i[id].proto == NSAPI_UDP) {
+    packet->remote_port = port;
+    memcpy(packet->remote_ip, _ip_buffer, 16);
+  }
+  packet->len = amount;
+  packet->alloc_len = amount;
+  packet->next = 0;
+
+  if (_parser.read((char *)(packet + 1), amount) < amount) {
+    free(packet);
+    _heap_usage -= pdu_len;
+    return;
+  }
+
+  // append to packet list
+  *_packets_end = packet;
+  _packets_end = &packet->next;
+}
+
+void OPL1000::_process_oob(duration<uint32_t, milli> timeout, bool all) {
+  set_timeout(timeout);
+  // Poll for inbound packets
+  while (_parser.process_oob() && all) {
+  }
+  set_timeout();
+}
+
+void OPL1000::bg_process_oob(duration<uint32_t, milli> timeout, bool all) {
+  _smutex.lock();
+  _process_oob(timeout, all);
+  _smutex.unlock();
+}
+
+int32_t OPL1000::_recv_tcp_passive(int id, void *data, uint32_t amount,
+                                   duration<uint32_t, milli> timeout) {
+  int32_t ret = NSAPI_ERROR_WOULD_BLOCK;
+
+  _smutex.lock();
+
+  _process_oob(timeout, true);
+
+  if (_sock_i[id].tcp_data_avbl != 0) {
+    _sock_i[id].tcp_data = (char *)data;
+    _sock_i[id].tcp_data_rcvd = NSAPI_ERROR_WOULD_BLOCK;
+    _sock_active_id = id;
+
+    // +CIPRECVDATA supports up to 2048 bytes at a time
+    amount = amount > 2048 ? 2048 : amount;
+
+    // NOTE: documentation v3.0 says '+CIPRECVDATA:<data_len>,' but it's not
+    // how the FW responds...
+    bool done = _parser.send("AT+CIPRECVDATA=%d,%" PRIu32, id, amount) &&
+                _parser.recv("OK\n");
+
+    _sock_i[id].tcp_data = NULL;
+    _sock_active_id = -1;
+
+    if (!done) {
+      goto BUSY;
+    }
+
+    // update internal variable tcp_data_avbl to reflect the remaining data
+    if (_sock_i[id].tcp_data_rcvd > 0) {
+      if (_sock_i[id].tcp_data_rcvd > (int32_t)amount) {
+        MBED_ERROR(MBED_MAKE_ERROR(MBED_MODULE_DRIVER, MBED_ERROR_CODE_EBADMSG),
+                   "OPL1000::_recv_tcp_passive() too much data from modem\n");
+      }
+      if (_sock_i[id].tcp_data_avbl > _sock_i[id].tcp_data_rcvd) {
+        _sock_i[id].tcp_data_avbl -= _sock_i[id].tcp_data_rcvd;
+      } else {
+        _sock_i[id].tcp_data_avbl = 0;
+      }
+    }
+
+    ret = _sock_i[id].tcp_data_rcvd;
+  }
+
+  if (!_sock_i[id].open && ret == NSAPI_ERROR_WOULD_BLOCK) {
+    ret = 0;
+  }
+
+  _smutex.unlock();
+  return ret;
+
+BUSY:
+  _process_oob(OPL1000_RECV_TIMEOUT, true);
+  if (_busy) {
+    tr_debug("_recv_tcp_passive(): Modem busy.");
+    ret = NSAPI_ERROR_WOULD_BLOCK;
+  } else {
+    tr_error("_recv_tcp_passive(): Unknown state.");
+    ret = NSAPI_ERROR_DEVICE_ERROR;
+  }
+  _smutex.unlock();
+  return ret;
+}
+
+int32_t OPL1000::recv_tcp(int id, void *data, uint32_t amount,
+                          duration<uint32_t, milli> timeout) {
+  if (_tcp_passive) {
+    return _recv_tcp_passive(id, data, amount, timeout);
+  }
+
+  _smutex.lock();
+
+  // No flow control, drain the USART receive register ASAP to avoid data
+  // overrun
+  if (_serial_rts == NC) {
+    _process_oob(timeout, true);
+  }
+
+  // check if any packets are ready for us
+  for (struct packet **p = &_packets; *p; p = &(*p)->next) {
+    if ((*p)->id == id) {
+      struct packet *q = *p;
+
+      if (q->len <= amount) {  // Return and remove full packet
+        memcpy(data, q + 1, q->len);
+
+        if (_packets_end == &(*p)->next) {
+          _packets_end = p;
+        }
+        *p = (*p)->next;
+
+        _smutex.unlock();
+
+        uint32_t pdu_len = sizeof(struct packet) + q->alloc_len;
+        uint32_t len = q->len;
+        free(q);
+        _heap_usage -= pdu_len;
+        return len;
+      } else {  // return only partial packet
+        memcpy(data, q + 1, amount);
+
+        q->len -= amount;
+        memmove(q + 1, (uint8_t *)(q + 1) + amount, q->len);
+
+        _smutex.unlock();
+        return amount;
+      }
+    }
+  }
+  if (!_sock_i[id].open) {
+    _smutex.unlock();
+    return 0;
+  }
+
+  // Flow control, read from USART receive register only when no more data is
+  // buffered, and as little as possible
+  if (_serial_rts != NC) {
+    _process_oob(timeout, false);
+  }
+  _smutex.unlock();
+
+  return NSAPI_ERROR_WOULD_BLOCK;
+}
+
+int32_t OPL1000::recv_udp(struct opl1000_socket *socket, void *data,
+                          uint32_t amount, duration<uint32_t, milli> timeout) {
+  _smutex.lock();
+  set_timeout(timeout);
+
+  // Process OOB data since this is
+  // how UDP packets are received
+  _process_oob(timeout, true);
+
+  set_timeout();
+
+  // check if any packets are ready for us
+  for (struct packet **p = &_packets; *p; p = &(*p)->next) {
+    if ((*p)->id == socket->id) {
+      struct packet *q = *p;
+
+      socket->addr.set_ip_address((*p)->remote_ip);
+      socket->addr.set_port((*p)->remote_port);
+
+      // Return and remove packet (truncated if necessary)
+      uint32_t len = q->len < amount ? q->len : amount;
+      memcpy(data, q + 1, len);
+
+      if (_packets_end == &(*p)->next) {
+        _packets_end = p;
+      }
+      *p = (*p)->next;
+      _smutex.unlock();
+
+      uint32_t pdu_len = sizeof(struct packet) + q->alloc_len;
+      free(q);
+      _heap_usage -= pdu_len;
+      return len;
+    }
+  }
+
+  // Flow control, read from USART receive register only when no more data is
+  // buffered, and as little as possible
+  if (_serial_rts != NC) {
+    _process_oob(timeout, false);
+  }
+
+  _smutex.unlock();
+
+  return NSAPI_ERROR_WOULD_BLOCK;
+}
+
+void OPL1000::_clear_socket_packets(int id) {
+  struct packet **p = &_packets;
+
+  while (*p) {
+    if ((*p)->id == id || id == OPL1000_ALL_SOCKET_IDS) {
+      struct packet *q = *p;
+      int pdu_len = sizeof(struct packet) + q->alloc_len;
+
+      if (_packets_end == &(*p)->next) {
+        _packets_end = p;  // Set last packet next field/_packets
+      }
+      *p = (*p)->next;
+      free(q);
+      _heap_usage -= pdu_len;
+    } else {
+      // Point to last packet next field
+      p = &(*p)->next;
+    }
+  }
+  if (id == OPL1000_ALL_SOCKET_IDS) {
+    for (int id = 0; id < 5; id++) {
+      _sock_i[id].tcp_data_avbl = 0;
+    }
+  } else {
+    _sock_i[id].tcp_data_avbl = 0;
+  }
+}
+
+void OPL1000::_clear_socket_sending(int id) {
+  if (id == _sock_sending_id) {
+    _sock_sending_id = -1;
+  }
+  _sock_i[id].send_fail = false;
+}
+
+bool OPL1000::close(int id) {
+  if (_sock_i[id].open == false) {
+    return true;
+  }
+  // May take a second try if device is busy
+  for (unsigned i = 0; i < 2; i++) {
+    _smutex.lock();
+    if (_parser.send("AT+CIPCLOSE=%d", id)) {
+      if (!_parser.recv("OK\n")) {
+        if (_closed) {  // UNLINK ERROR
+          _closed = false;
+          _sock_i[id].open = false;
+          _clear_socket_packets(id);
+          // Closed, so this socket escapes from SEND FAIL status.
+          _clear_socket_sending(id);
+          _smutex.unlock();
+          // OPL1000 has a habit that it might close a socket on its own.
+          tr_debug("close(%d): socket close OK with UNLINK ERROR", id);
+          return true;
+        }
+      } else {
+        // _sock_i[id].open set to false with an OOB
+        _clear_socket_packets(id);
+        // Closed, so this socket escapes from SEND FAIL status
+        _clear_socket_sending(id);
+        _smutex.unlock();
+        tr_debug("close(%d): socket close OK with AT+CIPCLOSE OK", id);
+        return true;
+      }
+    }
+    _smutex.unlock();
+  }
+  tr_debug("close(%d): socket close FAIL'ed (spurious close)", id);
+
+  return false;
+}
+
+void OPL1000::set_timeout(duration<uint32_t, milli> timeout) {
+  _parser.set_timeout(timeout.count());
+}
+
+bool OPL1000::readable() { return _serial.FileHandle::readable(); }
+
+bool OPL1000::writeable() { return _serial.FileHandle::writable(); }
+
+void OPL1000::sigio(Callback<void()> func) {
+  _serial.sigio(func);
+  _callback = func;
+}
+
+void OPL1000::attach(Callback<void()> status_cb) { _conn_stat_cb = status_cb; }
+
+bool OPL1000::_recv_ap(nsapi_wifi_ap_t *ap) { return false; }  // Not Supported
+
+void OPL1000::_oob_watchdog_reset() {
+  MBED_ERROR(MBED_MAKE_ERROR(MBED_MODULE_DRIVER, MBED_ERROR_CODE_ETIME),
+             "_oob_watchdog_reset() modem watchdog reset triggered\n");
+}
+
+void OPL1000::_oob_ready() {
+  _reset_done = true;
+
+  for (int i = 0; i < SOCKET_COUNT; i++) {
+    _sock_i[i].open = false;
+  }
+
+  // Makes possible to reinitialize
+  _conn_status = NSAPI_STATUS_ERROR_UNSUPPORTED;
+  _conn_stat_cb();
+
+  tr_debug("_oob_reset(): Reset detected.");
+}
+
+void OPL1000::_oob_busy() {
+  char status;
+  if (_parser.scanf("%c...\n", &status)) {
+    if (status == 's') {
+      tr_debug("_oob_busy(): Busy s...");
+    } else if (status == 'p') {
+      tr_debug("_oob_busy(): Busy p...");
+    } else {
+      tr_error("_oob_busy(): unrecognized busy state '%c...'", status);
+      MBED_ERROR(MBED_MAKE_ERROR(MBED_MODULE_DRIVER, MBED_ERROR_CODE_EBADMSG),
+                 "OPL1000::_oob_busy() unrecognized busy state\n");
+    }
+  } else {
+    MBED_ERROR(MBED_MAKE_ERROR(MBED_MODULE_DRIVER, MBED_ERROR_CODE_ENOMSG),
+               "OPL1000::_oob_busy() AT timeout\n");
+  }
+  _busy = true;
+}
+
+void OPL1000::_oob_tcp_data_hdlr() {
+  int32_t len;
+
+  MBED_ASSERT(_sock_active_id >= 0 && _sock_active_id < 5);
+
+  if (!_parser.scanf("%" SCNd32 ":", &len)) {
+    return;
+  }
+
+  if (_parser.read(_sock_i[_sock_active_id].tcp_data, len) == -1) {
+    return;
+  }
+
+  _sock_i[_sock_active_id].tcp_data_rcvd = len;
+}
+
+// void OPL1000::_oob_scan_results() {
+//   nsapi_wifi_ap_t ap;
+
+//   if (_recv_ap(&ap)) {
+//     if (_scan_r.res && _scan_r.cnt < _scan_r.limit) {
+//       _scan_r.res[_scan_r.cnt] = WiFiAccessPoint(ap);
+//     }
+
+//     _scan_r.cnt++;
+//   }
+// }
+
+void OPL1000::_oob_connect_err() {
+  _fail = false;
+  _connect_error = 0;
+
+  if (_parser.scanf("%d", &_connect_error) && _parser.scanf("FAIL")) {
+    _fail = true;
+    _parser.abort();
+  }
+}
+
+void OPL1000::_oob_conn_already() {
+  _sock_already = true;
+  _parser.abort();
+}
+
+void OPL1000::_oob_err() {
+  _error = true;
+  _parser.abort();
+}
+
+void OPL1000::_oob_socket_close_err() {
+  if (_error) {
+    _error = false;
+  }
+  _closed = true;  // Not possible to pinpoint to a certain socket
+}
+
+void OPL1000::_oob_socket0_closed() {
+  static const int id = 0;
+  _sock_i[id].open = false;
+  // Closed, so this socket escapes from SEND FAIL status
+  _clear_socket_sending(id);
+  tr_debug("_oob_socket0_closed(): Socket %d closed.", id);
+}
+
+void OPL1000::_oob_socket1_closed() {
+  static const int id = 1;
+  _sock_i[id].open = false;
+  // Closed, so this socket escapes from SEND FAIL status
+  _clear_socket_sending(id);
+  tr_debug("_oob_socket1_closed(): Socket %d closed.", id);
+}
+
+void OPL1000::_oob_socket2_closed() {
+  static const int id = 2;
+  _sock_i[id].open = false;
+  _clear_socket_sending(id);
+  tr_debug("_oob_socket2_closed(): Socket %d closed.", id);
+}
+
+void OPL1000::_oob_socket3_closed() {
+  static const int id = 3;
+  _sock_i[id].open = false;
+  _clear_socket_sending(id);
+  tr_debug("_oob_socket3_closed(): %d closed.", id);
+}
+
+void OPL1000::_oob_socket4_closed() {
+  static const int id = 4;
+  _sock_i[id].open = false;
+  // Closed, so this socket escapes from SEND FAIL status
+  _clear_socket_sending(id);
+  tr_debug("_oob_socket0_closed(): Socket %d closed.", id);
+}
+
+void OPL1000::_oob_connection_status() {
+  char status[13];
+  if (_parser.recv("%12[^\"]\n", status)) {
+    if (strcmp(status, "GOT IP\n") == 0) {
+      _conn_status = NSAPI_STATUS_GLOBAL_UP;
+    } else if (strcmp(status, "DISCONNECT\n") == 0) {
+      if (_disconnect) {
+        _conn_status = NSAPI_STATUS_DISCONNECTED;
+        _disconnect = false;
+      } else {
+        _conn_status = NSAPI_STATUS_CONNECTING;
+      }
+    } else if (strcmp(status, "CONNECTED\n") == 0) {
+      _conn_status = NSAPI_STATUS_CONNECTING;
+    } else {
+      tr_error("_oob_connection_status(): Invalid AT cmd \'%s\' .", status);
+      MBED_ERROR(MBED_MAKE_ERROR(MBED_MODULE_DRIVER, MBED_ERROR_CODE_EBADMSG),
+                 "OPL1000::_oob_connection_status: invalid AT cmd\n");
+    }
+  } else {
+    tr_error(
+        "_oob_connection_status(): Network status timeout, disconnecting.");
+    if (!disconnect()) {
+      tr_warning(
+          "_oob_connection_status(): Driver initiated disconnect failed.");
+    } else {
+      tr_debug("_oob_connection_status(): Disconnected.");
+    }
+    _conn_status = NSAPI_STATUS_ERROR_UNSUPPORTED;
+  }
+
+  MBED_ASSERT(_conn_stat_cb);
+  _conn_stat_cb();
+}
+
+void OPL1000::_oob_send_ok_received() {
+  tr_debug("_oob_send_ok_received called for socket %d", _sock_sending_id);
+  _sock_sending_id = -1;
+}
+
+void OPL1000::_oob_send_fail_received() {
+  tr_debug("_oob_send_fail_received called for socket %d", _sock_sending_id);
+  if (_sock_sending_id >= 0 && _sock_sending_id < SOCKET_COUNT) {
+    _sock_i[_sock_sending_id].send_fail = true;
+  }
+  _sock_sending_id = -1;
+}
+
+void OPL1000::flush() {
+  _smutex.lock();
+  _parser.flush();
+  _smutex.unlock();
+}
+
+nsapi_connection_status_t OPL1000::connection_status() const {
+  return _conn_status;
+}
+
+int OPL1000::uart_enable_input(bool enabled) {
+  return _serial.enable_input(enabled);
+}
+
+#endif
diff --git a/connectivity/drivers/wifi/opl1000-driver/OPL1000/OPL1000.h b/connectivity/drivers/wifi/opl1000-driver/OPL1000/OPL1000.h
new file mode 100644
index 0000000000..aa0656f6a2
--- /dev/null
+++ b/connectivity/drivers/wifi/opl1000-driver/OPL1000/OPL1000.h
@@ -0,0 +1,491 @@
+/* OPL1000 Example refrerence from esp8266-driver.
+ */
+
+#ifndef OPL1000_H
+#define OPL1000_H
+
+#if DEVICE_SERIAL && DEVICE_INTERRUPTIN &&                                   \
+    defined(MBED_CONF_EVENTS_PRESENT) && defined(MBED_CONF_NSAPI_PRESENT) && \
+    defined(MBED_CONF_RTOS_API_PRESENT)
+#include <stdint.h>
+
+#include <ctime>
+
+#include "PinNames.h"
+#include "drivers/BufferedSerial.h"
+#include "netsocket/SocketAddress.h"
+#include "netsocket/WiFiAccessPoint.h"
+#include "netsocket/nsapi_types.h"
+#include "platform/ATCmdParser.h"
+#include "platform/Callback.h"
+#include "platform/mbed_chrono.h"
+#include "platform/mbed_error.h"
+#include "rtos/Mutex.h"
+#include "rtos/ThisThread.h"
+
+// Various timeouts for different OPL1000 operations
+// (some of these can't use literal form as they're needed for defaults in this
+// header, where we shouldn't add a using directive for them. Defines only used
+// in the C++ file can use literals).
+#ifndef OPL1000_CONNECT_TIMEOUT
+#define OPL1000_CONNECT_TIMEOUT 15s
+#endif
+#ifndef OPL1000_SEND_TIMEOUT
+#define OPL1000_SEND_TIMEOUT 2s
+#endif
+#ifndef OPL1000_RECV_TIMEOUT
+#define OPL1000_RECV_TIMEOUT std::chrono::seconds(3)
+#endif
+#ifndef OPL1000_MISC_TIMEOUT
+#define OPL1000_MISC_TIMEOUT std::chrono::seconds(2)
+#endif
+#ifndef OPL1000_DNS_TIMEOUT
+#define OPL1000_DNS_TIMEOUT 15s
+#endif
+
+#define OPL1000_SCAN_TIME_MIN 0ms
+#define OPL1000_SCAN_TIME_MAX 1500ms
+#define OPL1000_SCAN_TIME_MIN_DEFAULT 120ms
+#define OPL1000_SCAN_TIME_MAX_DEFAULT 360ms
+
+// Firmware version
+#define OPL1000_SDK_VERSION 2000000
+#define OPL1000_SDK_VERSION_MAJOR OPL1000_SDK_VERSION / 1000000
+
+#define OPL1000_AT_VERSION 1000000
+#define OPL1000_AT_VERSION_MAJOR OPL1000_AT_VERSION / 1000000
+#define EOPL1000_AT_VERSION_TCP_PASSIVE_MODE 1070000
+#define OPL1000_AT_VERSION_WIFI_SCAN_CHANGE 1060000
+
+#define FW_AT_LEAST_VERSION(MAJOR, MINOR, PATCH, NUSED /*Not used*/, REF) \
+  (((MAJOR)*1000000 + (MINOR)*10000 + (PATCH)*100) >= REF ? true : false)
+
+struct opl1000_socket {
+  int id;
+  nsapi_protocol_t proto;
+  bool connected;
+  bool bound;
+  SocketAddress addr;
+  int keepalive;  // TCP
+};
+
+/** OPL1000Interface class.
+    This is an interface to a OPL1000 radio.
+ */
+class OPL1000 {
+ public:
+  OPL1000(PinName tx, PinName rx, bool debug = false, PinName rts = NC,
+          PinName cts = NC);
+
+  /**
+   * OPL1000 firmware AT version
+   *
+   * @param major Major version number
+   * @param minor Minor version number
+   * @param patch Patch version number
+   */
+  struct fw_at_version {
+    int major;
+    int minor;
+    fw_at_version(int major, int minor) : major(major), minor(minor) {}
+  };
+
+  /**
+   * Check AT command interface of OPL1000
+   *
+   * @return true if ready to respond on AT commands
+   */
+  bool at_available(void);
+
+  /**
+   * Disable echo - required for OOB processing to work
+   *
+   * @return true if echo was successfully disabled
+   */
+  bool echo_off(void);
+
+  /**
+   * Check sdk version from which firmware is created
+   *
+   * @return sdk_version which tells sdk version
+   */
+  int sdk_version(void);
+
+  /**
+   * Check AT instruction set version from which firmware is created
+   *
+   * @return fw_at_version which tells major, minor and patch version
+   */
+  struct fw_at_version at_version(void);
+
+  /**
+   * Startup the OPL1000
+   *
+   * @return true only if OPL1000 was setup correctly
+   */
+  bool startup();
+
+  /**
+   * Reset OPL1000
+   *
+   * @return true only if OPL1000 resets successfully
+   */
+  bool reset(void);
+
+  /**
+   * Connect OPL1000 to AP
+   *
+   * @param ap the name of the AP
+   * @param passPhrase the password of AP
+   * @return NSAPI_ERROR_OK in success, negative error code in failure
+   */
+  nsapi_error_t connect(const char *ap, const char *passPhrase);
+
+  /**
+   * Disconnect OPL1000 from AP
+   *
+   * @return true only if OPL1000 is disconnected successfully
+   */
+  bool disconnect(void);
+
+  /**
+   * Enable or disable Remote IP and Port printing with +IPD
+   *
+   * @param enable, 1 on, 0 off
+   * @return true only if OPL1000 is disconnected successfully
+   */
+  bool ip_info_print(int enable);
+
+  /**
+   * Get the IP address of OPL1000
+   *
+   * @return null-teriminated IP address or null if no IP address is assigned
+   */
+  const char *ip_addr(void);
+
+  /**
+   * Set static IP address, gateway and netmask
+   *
+   * @param ip IP address to set
+   * @param gateway (optional) gateway to set
+   * @param netmask (optional) netmask to set
+   *
+   * @return true if operation was successful and flase otherwise
+   */
+  bool set_ip_addr(const char *ip, const char *gateway, const char *netmask);
+
+  /**
+   * Get the MAC address of OPL1000
+   *
+   * @return null-terminated MAC address or null if no MAC address is assigned
+   */
+  const char *mac_addr(void);
+
+  /** Get the local gateway
+   *
+   *  @return         Null-terminated representation of the local gateway
+   *                  or null if no network mask has been recieved
+   */
+  const char *gateway();
+
+  /** Get the local network mask
+   *
+   *  @return         Null-terminated representation of the local network mask
+   *                  or null if no network mask has been recieved
+   */
+  const char *netmask();
+
+  /* Return RSSI for active connection
+   *
+   * @return      Measured RSSI
+   */
+  int8_t rssi();
+
+  /** Scan mode
+   */
+
+  /**Perform a dns query
+   *
+   * @param name Hostname to resolve
+   * @param ip   Buffer to store IP address
+   * @return 0 true on success, false on failure
+   */
+  bool dns_lookup(const char *name, char *ip);
+
+  /**
+   * Open a socketed connection
+   *
+   * @param type the type of socket to open "UDP" or "TCP"
+   * @param id id to give the new socket, valid 0-4
+   * @param port port to open connection with
+   * @param addr the IP address of the destination
+   * @param port the port on the destination
+   * @param local_port UDP socket's local port, zero means any
+   * @param udp_mode UDP socket's mode, zero means can't change remote, 1 can
+   * change once, 2 can change multiple times
+   * @return NSAPI_ERROR_OK in success, negative error code in failure
+   */
+  nsapi_error_t open_udp(int id, const char *addr, int port, int local_port = 0,
+                         int udp_mode = 0);
+
+  /**
+   * Open a socketed connection
+   *
+   * @param type the type of socket to open "UDP" or "TCP"
+   * @param id id to give the new socket, valid 0-4
+   * @param port port to open connection with
+   * @param addr the IP address of the destination
+   * @param port the port on the destination
+   * @param tcp_keepalive TCP connection's keep alive time, zero means disabled
+   * @return NSAPI_ERROR_OK in success, negative error code in failure
+   */
+  nsapi_error_t open_tcp(int id, const char *addr, int port, int keepalive = 0);
+
+  /**
+   * Sends data to an open socket
+   *
+   * @param id id of socket to send to
+   * @param data data to be sent
+   * @param amount amount of data to be sent - max 2048
+   * @return number of bytes on success, negative error code in failure
+   */
+  nsapi_size_or_error_t send(int id, const void *data, uint32_t amount);
+
+  /**
+   * Receives datagram from an open UDP socket
+   *
+   * @param id id to receive from
+   * @param data placeholder for returned information
+   * @param amount number of bytes to be received
+   * @return the number of bytes received
+   */
+  int32_t recv_udp(
+      struct opl1000_socket *socket, void *data, uint32_t amount,
+      mbed::chrono::milliseconds_u32 timeout = OPL1000_RECV_TIMEOUT);
+
+  /**
+   * Receives stream data from an open TCP socket
+   *
+   * @param id id to receive from
+   * @param data placeholder for returned information
+   * @param amount number of bytes to be received
+   * @return the number of bytes received
+   */
+  int32_t recv_tcp(
+      int id, void *data, uint32_t amount,
+      mbed::chrono::milliseconds_u32 timeout = OPL1000_RECV_TIMEOUT);
+
+  /**
+   * Closes a socket
+   *
+   * @param id id of socket to close, valid only 0-4
+   * @return true only if socket is closed successfully
+   */
+  bool close(int id);
+
+  /**
+   * Allows timeout to be changed between commands
+   *
+   * @param timeout_ms timeout of the connection
+   */
+  void set_timeout(
+      mbed::chrono::milliseconds_u32 timeout = OPL1000_MISC_TIMEOUT);
+
+  /**
+   * Checks if data is available
+   */
+  bool readable();
+
+  /**
+   * Checks if data can be written
+   */
+  bool writeable();
+
+  /**
+   * Attach a function to call whenever sigio happens in the serial
+   *
+   * @param func A pointer to a void function, or 0 to set as none
+   */
+  void sigio(mbed::Callback<void()> func);
+
+  /**
+   * Attach a function to call whenever sigio happens in the serial
+   *
+   * @param obj pointer to the object to call the member function on
+   * @param method pointer to the member function to call
+   */
+  template <typename T, typename M>
+  void sigio(T *obj, M method) {
+    sigio(mbed::Callback<void()>(obj, method));
+  }
+
+  /**
+   * Attach a function to call whenever network state has changed.
+   *
+   * @param func A pointer to a void function, or 0 to set as none
+   */
+  void attach(mbed::Callback<void()> status_cb);
+
+  template <typename T, typename M>
+  void attach(T *obj, M method) {
+    attach(mbed::Callback<void()>(obj, method));
+  }
+
+  /** Get the connection status
+   *
+   *  @return         The connection status according to ConnectionStatusType
+   */
+  nsapi_connection_status_t connection_status() const;
+
+  /**
+   * Start board's and OPL1000's UART flow control
+   *
+   * @return true if started
+   */
+  bool start_uart_hw_flow_ctrl();
+
+  /**
+   * Stop board's and OPL1000's UART flow control
+   *
+   * @return true if started
+   */
+  bool stop_uart_hw_flow_ctrl();
+
+  /**
+   * For executing OOB processing on background
+   *
+   * @param timeout AT parser receive timeout
+   * @param if TRUE, process all OOBs instead of only one
+   */
+  void bg_process_oob(std::chrono::duration<uint32_t, std::milli> timeout,
+                      bool all);
+
+  /**
+   * Flush the serial port input buffers.
+   *
+   * If you do HW reset for ESP module, you should
+   * flush the input buffers from existing responses
+   * from the device.
+   */
+  void flush();
+
+  static const int8_t WIFIMODE_STATION = 1;
+  static const int8_t WIFIMODE_SOFTAP = 2;
+  static const int8_t WIFIMODE_STATION_SOFTAP = 3;
+  static const int8_t SOCKET_COUNT = 5;
+
+  /**
+   * Enables or disables uart input and deep sleep
+   *
+   * @param lock if TRUE, uart input is enabled and  deep sleep is locked
+   * if FALSE, uart input is disabled and  deep sleep is unlocked
+   */
+  int uart_enable_input(bool lock);
+
+ private:
+  // FW version
+  int _sdk_v;
+  struct fw_at_version _at_v;
+
+  // FW version specific settings and functionalities
+  bool _tcp_passive;
+  int32_t _recv_tcp_passive(
+      int id, void *data, uint32_t amount,
+      std::chrono::duration<uint32_t, std::milli> timeout);
+  mbed::Callback<void()> _callback;
+
+  // UART settings
+  mbed::BufferedSerial _serial;
+  PinName _serial_rts;
+  PinName _serial_cts;
+  rtos::Mutex _smutex;  // Protect serial port access
+
+  // AT Command Parser
+  mbed::ATCmdParser _parser;
+
+  // Wifi scan result handling
+  bool _recv_ap(nsapi_wifi_ap_t *ap);
+
+  // Socket data buffer
+  struct packet {
+    struct packet *next;
+    int id;
+    char remote_ip[16];
+    int remote_port;
+    uint32_t len;        // Remaining length
+    uint32_t alloc_len;  // Original length
+                         // data follows
+  } * _packets, **_packets_end;
+  void _clear_socket_packets(int id);
+  void _clear_socket_sending(int id);
+  int _sock_active_id;
+
+  // Memory statistics
+  size_t _heap_usage;  // (Socket data buffer usage)
+
+  // OOB processing
+  void _process_oob(std::chrono::duration<uint32_t, std::milli> timeout,
+                    bool all);
+
+  // OOB message handlers
+  void _oob_packet_hdlr();
+  void _oob_connect_err();
+  void _oob_conn_already();
+  void _oob_err();
+  void _oob_socket0_closed();
+  void _oob_socket1_closed();
+  void _oob_socket2_closed();
+  void _oob_socket3_closed();
+  void _oob_socket4_closed();
+  void _oob_connection_status();
+  void _oob_socket_close_err();
+  void _oob_watchdog_reset();
+  void _oob_busy();
+  void _oob_tcp_data_hdlr();
+  void _oob_ready();
+  // void _oob_scan_results();
+  void _oob_send_ok_received();
+  void _oob_send_fail_received();
+
+  // OOB state variables
+  int _connect_error;
+  bool _disconnect;
+  bool _fail;
+  bool _sock_already;
+  bool _closed;
+  bool _error;
+  bool _busy;
+  bool _reset_done;
+  int _sock_sending_id;
+
+  // Modem's address info
+  char _ip_buffer[16];
+  char _gateway_buffer[16];
+  char _netmask_buffer[16];
+  char _mac_buffer[18];
+
+  // Modem's socket info
+  struct _sock_info {
+    bool open;
+    nsapi_protocol_t proto;
+    char *tcp_data;
+    int32_t tcp_data_avbl;  // Data waiting on modem
+    int32_t tcp_data_rcvd;
+    bool send_fail;  // Received 'SEND FAIL'. Expect user will close the socket.
+  };
+  struct _sock_info _sock_i[SOCKET_COUNT];
+
+  // Scan results
+  struct _scan_results {
+    WiFiAccessPoint *res;
+    unsigned limit;
+    unsigned cnt;
+  };
+  struct _scan_results _scan_r;
+
+  // Connection state reporting
+  nsapi_connection_status_t _conn_status;
+  mbed::Callback<void()> _conn_stat_cb;  // OPL1000Interface registered
+};
+#endif
+#endif
diff --git a/connectivity/drivers/wifi/opl1000-driver/OPL1000Interface.cpp b/connectivity/drivers/wifi/opl1000-driver/OPL1000Interface.cpp
new file mode 100644
index 0000000000..e0b5f8f1f7
--- /dev/null
+++ b/connectivity/drivers/wifi/opl1000-driver/OPL1000Interface.cpp
@@ -0,0 +1,1091 @@
+/* OPL1000 implementation of NetworkInterfaceAPI refrerence from esp8266-driver.
+ */
+
+#if DEVICE_SERIAL && DEVICE_INTERRUPTIN &&                                   \
+    defined(MBED_CONF_EVENTS_PRESENT) && defined(MBED_CONF_NSAPI_PRESENT) && \
+    defined(MBED_CONF_RTOS_API_PRESENT)
+
+#include "OPL1000Interface.h"
+
+#include <stdint.h>
+#include <string.h>
+
+#include "OPL1000.h"
+#include "events/EventQueue.h"
+#include "events/mbed_shared_queues.h"
+#include "mbed_trace.h"
+#include "netsocket/nsapi_types.h"
+#include "platform/Callback.h"
+#include "platform/mbed_atomic.h"
+#include "platform/mbed_debug.h"
+#include "rtos/ThisThread.h"
+
+using namespace std::chrono;
+
+#ifndef MBED_CONF_OPL1000_DEBUG
+#define MBED_CONF_OPL1000_DEBUG false
+#endif
+
+#ifndef MBED_CONF_OPL1000_RTS
+#define MBED_CONF_OPL1000_RTS NC
+#endif
+
+#ifndef MBED_CONF_OPL1000_CTS
+#define MBED_CONF_OPL1000_CTS NC
+#endif
+
+#ifndef MBED_CONF_OPL1000_RST
+#define MBED_CONF_OPL1000_RST NC
+#endif
+
+#ifndef MBED_CONF_OPL1000_PWR
+#define MBED_CONF_OPL1000_PWR NC
+#endif
+
+#define TRACE_GROUP "OPLI"  // OPL1000 Interface
+
+#define OPL1000_WIFI_IF_NAME "opl0"
+
+using namespace mbed;
+using namespace rtos;
+
+#if defined MBED_CONF_OPL1000_TX && defined MBED_CONF_OPL1000_RX
+OPL1000Interface::OPL1000Interface()
+    : _esp(MBED_CONF_OPL1000_TX, MBED_CONF_OPL1000_RX, MBED_CONF_OPL1000_DEBUG,
+           MBED_CONF_OPL1000_RTS, MBED_CONF_OPL1000_CTS),
+      _rst_pin(MBED_CONF_OPL1000_RST),  // Notice that Pin7 CH_EN cannot be left
+                                        // floating if used as reset
+      _pwr_pin(MBED_CONF_OPL1000_PWR),
+      _ap_sec(NSAPI_SECURITY_UNKNOWN),
+      _if_blocking(true),
+#if MBED_CONF_RTOS_PRESENT
+      _if_connected(_cmutex),
+#endif
+      _initialized(false),
+      _connect_retval(NSAPI_ERROR_OK),
+      _disconnect_retval(NSAPI_ERROR_OK),
+      _conn_stat(NSAPI_STATUS_DISCONNECTED),
+      _conn_stat_cb(),
+      _global_event_queue(mbed_event_queue()),  // Needs to be set before
+                                                // attaching event() to SIGIO
+      _oob_event_id(0),
+      _connect_event_id(0),
+      _disconnect_event_id(0),
+      _software_conn_stat(IFACE_STATUS_DISCONNECTED) {
+  memset(_cbs, 0, sizeof(_cbs));
+  memset(ap_ssid, 0, sizeof(ap_ssid));
+  memset(ap_pass, 0, sizeof(ap_pass));
+
+  _ch_info.track_ap = true;
+  strncpy(_ch_info.country_code, MBED_CONF_OPL1000_COUNTRY_CODE,
+          sizeof(_ch_info.country_code));
+  _ch_info.channel_start = MBED_CONF_OPL1000_CHANNEL_START;
+  _ch_info.channels = MBED_CONF_OPL1000_CHANNELS;
+
+  _esp.sigio(this, &OPL1000Interface::event);
+  _esp.set_timeout();
+  _esp.attach(this, &OPL1000Interface::refresh_conn_state_cb);
+
+  for (int i = 0; i < OPL1000_SOCKET_COUNT; i++) {
+    _sock_i[i].open = false;
+    _sock_i[i].sport = 0;
+  }
+  _esp.uart_enable_input(false);
+}
+#endif
+
+// OPL1000Interface implementation
+OPL1000Interface::OPL1000Interface(PinName tx, PinName rx, bool debug,
+                                   PinName rts, PinName cts, PinName rst,
+                                   PinName pwr)
+    : _esp(tx, rx, debug, rts, cts),
+      _rst_pin(rst),
+      _pwr_pin(pwr),
+      _ap_sec(NSAPI_SECURITY_UNKNOWN),
+      _if_blocking(true),
+#if MBED_CONF_RTOS_PRESENT
+      _if_connected(_cmutex),
+#endif
+      _initialized(false),
+      _connect_retval(NSAPI_ERROR_OK),
+      _disconnect_retval(NSAPI_ERROR_OK),
+      _conn_stat(NSAPI_STATUS_DISCONNECTED),
+      _conn_stat_cb(),
+      _global_event_queue(mbed_event_queue()),  // Needs to be set before
+                                                // attaching event() to SIGIO
+      _oob_event_id(0),
+      _connect_event_id(0),
+      _disconnect_event_id(0),
+      _software_conn_stat(IFACE_STATUS_DISCONNECTED) {
+  memset(_cbs, 0, sizeof(_cbs));
+  memset(ap_ssid, 0, sizeof(ap_ssid));
+  memset(ap_pass, 0, sizeof(ap_pass));
+
+  _ch_info.track_ap = true;
+  strncpy(_ch_info.country_code, MBED_CONF_OPL1000_COUNTRY_CODE,
+          sizeof(_ch_info.country_code));
+  _ch_info.channel_start = MBED_CONF_OPL1000_CHANNEL_START;
+  _ch_info.channels = MBED_CONF_OPL1000_CHANNELS;
+
+  _esp.sigio(this, &OPL1000Interface::event);
+  _esp.set_timeout();
+  _esp.attach(this, &OPL1000Interface::refresh_conn_state_cb);
+
+  for (int i = 0; i < OPL1000_SOCKET_COUNT; i++) {
+    _sock_i[i].open = false;
+    _sock_i[i].sport = 0;
+  }
+  _esp.uart_enable_input(false);
+}
+
+OPL1000Interface::~OPL1000Interface() {
+  if (_oob_event_id) {
+    _global_event_queue->cancel(_oob_event_id);
+  }
+
+  _cmutex.lock();
+  if (_connect_event_id) {
+    _global_event_queue->cancel(_connect_event_id);
+  }
+  _cmutex.unlock();
+
+  // Power down the modem
+  _rst_pin.rst_assert();
+  // Power off the modem
+  _pwr_pin.power_off();
+}
+
+OPL1000Interface::ResetPin::ResetPin(PinName rst_pin)
+    : _rst_pin(mbed::DigitalOut(rst_pin, 1)) {}
+
+void OPL1000Interface::ResetPin::rst_assert() {
+  if (_rst_pin.is_connected()) {
+    _rst_pin = 0;
+    tr_debug("rst_assert(): HW reset asserted.");
+  }
+}
+
+void OPL1000Interface::ResetPin::rst_deassert() {
+  if (_rst_pin.is_connected()) {
+    // Notice that Pin7 CH_EN cannot be left floating if used as reset
+    _rst_pin = 1;
+    tr_debug("rst_deassert(): HW reset deasserted.");
+  }
+}
+
+bool OPL1000Interface::ResetPin::is_connected() {
+  return _rst_pin.is_connected();
+}
+
+OPL1000Interface::PowerPin::PowerPin(PinName pwr_pin)
+    : _pwr_pin(
+          mbed::DigitalOut(pwr_pin, !MBED_CONF_OPL1000_POWER_ON_POLARITY)) {}
+
+void OPL1000Interface::PowerPin::power_on() {
+  if (_pwr_pin.is_connected()) {
+    _pwr_pin = MBED_CONF_OPL1000_POWER_ON_POLARITY;
+    tr_debug("power_on(): HW power-on.");
+    ThisThread::sleep_for(milliseconds(MBED_CONF_OPL1000_POWER_ON_TIME_MS));
+  }
+}
+
+void OPL1000Interface::PowerPin::power_off() {
+  if (_pwr_pin.is_connected()) {
+    _pwr_pin = !MBED_CONF_OPL1000_POWER_ON_POLARITY;
+    tr_debug("power_off(): HW power-off.");
+    ThisThread::sleep_for(milliseconds(MBED_CONF_OPL1000_POWER_OFF_TIME_MS));
+  }
+}
+
+void OPL1000Interface::_power_off() {
+  _rst_pin.rst_assert();
+  _pwr_pin.power_off();
+}
+
+bool OPL1000Interface::PowerPin::is_connected() {
+  return _pwr_pin.is_connected();
+}
+
+int OPL1000Interface::connect(const char *ssid, const char *pass,
+                              nsapi_security_t security, uint8_t channel) {
+  if (channel != 0) {
+    return NSAPI_ERROR_UNSUPPORTED;
+  }
+
+  int err = set_credentials(ssid, pass, security);
+  if (err) {
+    return err;
+  }
+  return connect();
+}
+
+void OPL1000Interface::_connect_async() {
+  nsapi_error_t status = _init();
+  if (status != NSAPI_ERROR_OK) {
+    _connect_retval = status;
+    _esp.uart_enable_input(false);
+    _software_conn_stat = IFACE_STATUS_DISCONNECTED;
+    //_conn_stat_cb will be called from refresh_conn_state_cb
+
+    return;
+  }
+
+  _cmutex.lock();
+  if (!_connect_event_id) {
+    tr_debug("_connect_async(): Cancelled.");
+    _cmutex.unlock();
+    return;
+  }
+  _connect_retval = _esp.connect(ap_ssid, ap_pass);
+  auto timepassed = _conn_timer.elapsed_time();
+  if (_connect_retval == NSAPI_ERROR_OK ||
+      _connect_retval == NSAPI_ERROR_AUTH_FAILURE ||
+      _connect_retval == NSAPI_ERROR_NO_SSID ||
+      ((_if_blocking == true) &&
+       (timepassed >= OPL1000_INTERFACE_CONNECT_TIMEOUT))) {
+    _connect_event_id = 0;
+    _conn_timer.stop();
+    if (timepassed >= OPL1000_INTERFACE_CONNECT_TIMEOUT &&
+        _connect_retval != NSAPI_ERROR_OK) {
+      _connect_retval = NSAPI_ERROR_CONNECTION_TIMEOUT;
+    }
+    if (_connect_retval != NSAPI_ERROR_OK) {
+      _esp.uart_enable_input(false);
+      _software_conn_stat = IFACE_STATUS_DISCONNECTED;
+    }
+#if MBED_CONF_RTOS_PRESENT
+    _if_connected.notify_all();
+#endif
+  } else {
+    // Postpone to give other stuff time to run
+    _connect_event_id = _global_event_queue->call_in(
+        OPL1000_INTERFACE_CONNECT_INTERVAL,
+        callback(this, &OPL1000Interface::_connect_async));
+    if (!_connect_event_id) {
+      MBED_ERROR(MBED_MAKE_ERROR(MBED_MODULE_DRIVER, MBED_ERROR_CODE_ENOMEM),
+                 "OPL1000Interface::_connect_async(): unable to add event to "
+                 " queue.Increase \"events.shared-eventsize\"\n");
+    }
+  }
+  _cmutex.unlock();
+
+  if (_connect_event_id == 0) {
+    if (_conn_stat_cb) {
+      _conn_stat_cb(NSAPI_EVENT_CONNECTION_STATUS_CHANGE, _conn_stat);
+    }
+    if (_conn_stat == NSAPI_STATUS_GLOBAL_UP ||
+        _conn_stat == NSAPI_STATUS_LOCAL_UP) {
+      _software_conn_stat = IFACE_STATUS_CONNECTED;
+    }
+  }
+}
+
+int OPL1000Interface::connect() {
+  if (_software_conn_stat == IFACE_STATUS_CONNECTING) {
+    return NSAPI_ERROR_BUSY;
+  }
+  if (_software_conn_stat == IFACE_STATUS_CONNECTED) {
+    return NSAPI_ERROR_IS_CONNECTED;
+  }
+
+  if (strlen(ap_ssid) == 0) {
+    return NSAPI_ERROR_NO_SSID;
+  }
+
+  if (_ap_sec != NSAPI_SECURITY_NONE) {
+    if (strlen(ap_pass) < OPL1000_PASSPHRASE_MIN_LENGTH) {
+      return NSAPI_ERROR_PARAMETER;
+    }
+  }
+  if (!_if_blocking) {
+    bool ret = _cmutex.trylock();
+    if (ret == false) {
+      return NSAPI_ERROR_BUSY;
+    }
+  } else {
+    _cmutex.lock();
+  }
+
+  _software_conn_stat = IFACE_STATUS_CONNECTING;
+  _esp.uart_enable_input(true);
+  _connect_retval = NSAPI_ERROR_NO_CONNECTION;
+  MBED_ASSERT(!_connect_event_id);
+  _conn_timer.stop();
+  _conn_timer.reset();
+  _conn_timer.start();
+  _connect_event_id = _global_event_queue->call(
+      callback(this, &OPL1000Interface::_connect_async));
+  if (!_connect_event_id) {
+    MBED_ERROR(MBED_MAKE_ERROR(MBED_MODULE_DRIVER, MBED_ERROR_CODE_ENOMEM),
+               "connect(): unable to add event to queue. Increase "
+               "\"events.shared-eventsize\"\n");
+  }
+#if MBED_CONF_RTOS_PRESENT
+  while (_if_blocking &&
+         (_conn_status_to_error() != NSAPI_ERROR_IS_CONNECTED) &&
+         (_connect_retval == NSAPI_ERROR_NO_CONNECTION)) {
+    _if_connected.wait();
+  }
+#endif
+  _cmutex.unlock();
+
+  if (!_if_blocking) {
+    return NSAPI_ERROR_OK;
+  } else {
+    return _connect_retval;
+  }
+}
+
+int OPL1000Interface::set_credentials(const char *ssid, const char *pass,
+                                      nsapi_security_t security) {
+  nsapi_error_t status = _conn_status_to_error();
+  if (_software_conn_stat == IFACE_STATUS_CONNECTING) {
+    return NSAPI_ERROR_BUSY;
+  }
+  if (status != NSAPI_ERROR_NO_CONNECTION) {
+    return status;
+  }
+
+  _ap_sec = security;
+
+  if (!ssid) {
+    return NSAPI_ERROR_PARAMETER;
+  }
+
+  int ssid_length = strlen(ssid);
+
+  if (ssid_length > 0 && ssid_length <= OPL1000_SSID_MAX_LENGTH) {
+    memset(ap_ssid, 0, sizeof(ap_ssid));
+    strncpy(ap_ssid, ssid, OPL1000_SSID_MAX_LENGTH);
+  } else {
+    return NSAPI_ERROR_PARAMETER;
+  }
+
+  if (_ap_sec != NSAPI_SECURITY_NONE) {
+    if (!pass) {
+      return NSAPI_ERROR_PARAMETER;
+    }
+
+    int pass_length = strlen(pass);
+    if (pass_length >= OPL1000_PASSPHRASE_MIN_LENGTH &&
+        pass_length <= OPL1000_PASSPHRASE_MAX_LENGTH) {
+      memset(ap_pass, 0, sizeof(ap_pass));
+      strncpy(ap_pass, pass, OPL1000_PASSPHRASE_MAX_LENGTH);
+    } else {
+      return NSAPI_ERROR_PARAMETER;
+    }
+  } else {
+    memset(ap_pass, 0, sizeof(ap_pass));
+  }
+
+  return NSAPI_ERROR_OK;
+}
+
+int OPL1000Interface::set_channel(uint8_t channel) {
+  return NSAPI_ERROR_UNSUPPORTED;
+}
+
+nsapi_error_t OPL1000Interface::set_network(
+    const SocketAddress &ip_address, const SocketAddress &netmask,
+    const SocketAddress &gateway) {  // Not Supported
+  return NSAPI_ERROR_UNSUPPORTED;
+}
+
+nsapi_error_t OPL1000Interface::set_dhcp(bool dhcp) {
+  return NSAPI_ERROR_UNSUPPORTED;
+}
+
+void OPL1000Interface::_disconnect_async() {
+  _cmutex.lock();
+  _disconnect_retval =
+      _esp.disconnect() ? NSAPI_ERROR_OK : NSAPI_ERROR_DEVICE_ERROR;
+  // _esp.uart_enable_input(false);
+  auto timepassed = _conn_timer.elapsed_time();
+
+  if (_disconnect_retval == NSAPI_ERROR_OK ||
+      ((_if_blocking == true) &&
+       (timepassed >= OPL1000_INTERFACE_CONNECT_TIMEOUT))) {
+    if (timepassed >= OPL1000_INTERFACE_CONNECT_TIMEOUT &&
+        _connect_retval != NSAPI_ERROR_OK) {
+      _disconnect_retval = NSAPI_ERROR_CONNECTION_TIMEOUT;
+    } else {
+      if (_conn_stat != NSAPI_STATUS_DISCONNECTED) {
+        _conn_stat = NSAPI_STATUS_DISCONNECTED;
+      }
+      // In case the status update arrives later inform upper layers manually
+      _disconnect_event_id = 0;
+      _conn_timer.stop();
+      _connect_retval = NSAPI_ERROR_NO_CONNECTION;
+    }
+
+    _power_off();
+    _software_conn_stat = IFACE_STATUS_DISCONNECTED;
+#if MBED_CONF_RTOS_PRESENT
+    _if_connected.notify_all();
+#endif
+
+  } else {
+    // Postpone to give other stuff time to run
+    _disconnect_event_id = _global_event_queue->call_in(
+        OPL1000_INTERFACE_CONNECT_INTERVAL,
+        callback(this, &OPL1000Interface::_disconnect_async));
+    if (!_disconnect_event_id) {
+      MBED_ERROR(MBED_MAKE_ERROR(MBED_MODULE_DRIVER, MBED_ERROR_CODE_ENOMEM),
+                 "OPL1000Interface::_disconnect_async(): unable to add event "
+                 "to queue. Increase \"events.shared-eventsize\"\n");
+    }
+  }
+  _cmutex.unlock();
+
+  if (_disconnect_event_id == 0) {
+    if (_conn_stat_cb) {
+      _conn_stat_cb(NSAPI_EVENT_CONNECTION_STATUS_CHANGE, _conn_stat);
+    }
+  }
+}
+
+int OPL1000Interface::disconnect() {
+  if (_software_conn_stat == IFACE_STATUS_DISCONNECTING) {
+    return NSAPI_ERROR_BUSY;
+  }
+  if (_software_conn_stat == IFACE_STATUS_DISCONNECTED) {
+    return NSAPI_ERROR_NO_CONNECTION;
+  }
+  if (!_if_blocking) {
+    bool ret = _cmutex.trylock();
+    if (ret == false) {
+      return NSAPI_ERROR_BUSY;
+    }
+  } else {
+    _cmutex.lock();
+  }
+  if (_connect_event_id) {
+    _global_event_queue->cancel(_connect_event_id);
+    _connect_event_id =
+        0;  // cancel asynchronous connection attempt if one is ongoing
+  }
+  _software_conn_stat = IFACE_STATUS_DISCONNECTING;
+
+  _disconnect_retval = NSAPI_ERROR_IS_CONNECTED;
+  _disconnect_event_id = 0;
+
+  _initialized = false;
+  _conn_timer.stop();
+  _conn_timer.reset();
+  _conn_timer.start();
+  _disconnect_event_id = _global_event_queue->call(
+      callback(this, &OPL1000Interface::_disconnect_async));
+  if (!_disconnect_event_id) {
+    MBED_ERROR(MBED_MAKE_ERROR(MBED_MODULE_DRIVER, MBED_ERROR_CODE_ENOMEM),
+               "disconnect(): unable to add event to queue. Increase "
+               "\"events.shared-eventsize\"\n");
+  }
+#if MBED_CONF_RTOS_PRESENT
+  while (_if_blocking &&
+         (_conn_status_to_error() != NSAPI_ERROR_NO_CONNECTION) &&
+         (_disconnect_retval != NSAPI_ERROR_OK)) {
+    _if_connected.wait();
+  }
+#endif
+  _cmutex.unlock();
+  if (!_if_blocking) {
+    return NSAPI_ERROR_OK;
+  } else {
+    return _disconnect_retval;
+  }
+}
+
+nsapi_error_t OPL1000Interface::get_ip_address(SocketAddress *address) {
+  if (_software_conn_stat == IFACE_STATUS_DISCONNECTED) {
+    _esp.uart_enable_input(true);
+  }
+
+  const char *ip_buff = _esp.ip_addr();
+  if (!ip_buff || strcmp(ip_buff, "0.0.0.0") == 0) {
+    ip_buff = NULL;
+  }
+  if (_software_conn_stat == IFACE_STATUS_DISCONNECTED) {
+    _esp.uart_enable_input(false);
+  }
+  if (ip_buff) {
+    address->set_ip_address(ip_buff);
+    return NSAPI_ERROR_OK;
+  }
+  return NSAPI_ERROR_NO_ADDRESS;
+}
+
+const char *OPL1000Interface::get_mac_address() {
+  if (_software_conn_stat == IFACE_STATUS_DISCONNECTED) {
+    _esp.uart_enable_input(true);
+  }
+  const char *ret = _esp.mac_addr();
+
+  if (_software_conn_stat == IFACE_STATUS_DISCONNECTED) {
+    _esp.uart_enable_input(false);
+  }
+  return ret;
+}
+
+nsapi_error_t OPL1000Interface::get_gateway(SocketAddress *address) {
+  return NSAPI_ERROR_UNSUPPORTED;
+}
+
+const char *OPL1000Interface::get_gateway() { return NULL; }
+
+nsapi_error_t OPL1000Interface::get_netmask(SocketAddress *address) {
+  return NSAPI_ERROR_UNSUPPORTED;
+}
+
+const char *OPL1000Interface::get_netmask() { return NULL; }
+
+char *OPL1000Interface::get_interface_name(char *interface_name) {
+  memcpy(interface_name, OPL1000_WIFI_IF_NAME, sizeof(OPL1000_WIFI_IF_NAME));
+  return interface_name;
+}
+
+int8_t OPL1000Interface::get_rssi() { return -1; }
+
+int OPL1000Interface::scan(WiFiAccessPoint *res, unsigned count) { return -1; }
+
+int OPL1000Interface::scan(WiFiAccessPoint *res, unsigned count, scan_mode mode,
+                           mbed::chrono::milliseconds_u32 t_max,
+                           mbed::chrono::milliseconds_u32 t_min) {
+  return -1;
+}
+
+#if MBED_CONF_OPL1000_BUILT_IN_DNS
+nsapi_error_t OPL1000Interface::gethostbyname(const char *name,
+                                              SocketAddress *address,
+                                              nsapi_version_t version,
+                                              const char *interface_name) {
+  char ip[NSAPI_IPv4_SIZE];
+  memset(ip, 0, NSAPI_IPv4_SIZE);
+  if (!_esp.dns_lookup(name, ip)) {
+    return NSAPI_ERROR_DNS_FAILURE;
+  }
+  if (!address->set_ip_address(ip)) {
+    return NSAPI_ERROR_DNS_FAILURE;
+  }
+
+  return NSAPI_ERROR_OK;
+}
+
+nsapi_error_t OPL1000Interface::add_dns_server(const SocketAddress &address,
+                                               const char *interface_name) {
+  return NSAPI_ERROR_OK;
+}
+#endif
+
+bool OPL1000Interface::_get_firmware_ok() {
+  OPL1000::fw_at_version at_v = _esp.at_version();
+  if (at_v.major < OPL1000_AT_VERSION_MAJOR) {
+    debug("OPL1000: ERROR: AT Firmware v%d incompatible with this driver.",
+          at_v.major);
+    MBED_ERROR(MBED_MAKE_ERROR(MBED_MODULE_DRIVER, MBED_ERROR_UNSUPPORTED),
+               "Too old AT firmware");
+  }
+  int sdk_v = _esp.sdk_version();
+
+  return true;
+}
+
+nsapi_error_t OPL1000Interface::_init(void) {
+  if (!_initialized) {
+    // _pwr_pin.power_off();
+    // _pwr_pin.power_on();
+
+    // if (_reset() != NSAPI_ERROR_OK) {
+    //   printf("reset fail...\n");
+    //   return NSAPI_ERROR_DEVICE_ERROR;
+    // }
+    // if (!_esp.echo_off()) {
+    //   return NSAPI_ERROR_DEVICE_ERROR;
+    // }
+    // if (!_esp.start_uart_hw_flow_ctrl()) {
+    //   return NSAPI_ERROR_DEVICE_ERROR;
+    // }
+    // if (!_get_firmware_ok()) {
+    //   return NSAPI_ERROR_DEVICE_ERROR;
+    // }
+    // if (!_esp.startup()) {
+    //   return NSAPI_ERROR_DEVICE_ERROR;
+    // }
+    _initialized = true;
+  }
+  return NSAPI_ERROR_OK;
+}
+
+nsapi_error_t OPL1000Interface::_reset() {
+  // if (_rst_pin.is_connected()) {
+  //   _rst_pin.rst_assert();
+  //   // If you happen to use Pin7 CH_EN as reset pin, not needed otherwise
+  //   //
+  //   https://www.espressif.com/sites/default/files/documentation/esp8266_hardware_design_guidelines_en.pdf
+  //   // First need to round up when converting to kernel ticks (eg 200us ->
+  //   1ms). auto delay = duration_cast<Kernel::Clock::duration_u32>(200us); if
+  //   (delay < 200us) {
+  //     delay++;
+  //   }
+  //   // Then need to round the clock-resolution duration up; if we were at the
+  //   // end of a tick period, it might flip immediately.
+  //   delay++;
+  //   ThisThread::sleep_for(delay);
+  //   _esp.flush();
+  //   _rst_pin.rst_deassert();
+  // } else {
+  // _esp.flush();
+  // if (!_esp.at_available()) {
+  //   return NSAPI_ERROR_DEVICE_ERROR;
+  // }
+  // if (!_esp.reset()) {
+  //   return NSAPI_ERROR_DEVICE_ERROR;
+  // }
+  // }
+  return _esp.reset() ? NSAPI_ERROR_OK : NSAPI_ERROR_DEVICE_ERROR;
+  // return _esp.at_available() ? NSAPI_ERROR_OK : NSAPI_ERROR_DEVICE_ERROR;
+}
+
+int OPL1000Interface::socket_open(void **handle, nsapi_protocol_t proto) {
+  // Look for an unused socket
+  int id = -1;
+
+  for (int i = 0; i < OPL1000_SOCKET_COUNT; i++) {
+    if (!_sock_i[i].open) {
+      id = i;
+      _sock_i[i].open = true;
+      break;
+    }
+  }
+
+  if (id == -1) {
+    return NSAPI_ERROR_NO_SOCKET;
+  }
+
+  struct opl1000_socket *socket = new struct opl1000_socket;
+  if (!socket) {
+    return NSAPI_ERROR_NO_SOCKET;
+  }
+
+  socket->id = id;
+  socket->proto = proto;
+  socket->connected = false;
+  socket->bound = false;
+  socket->keepalive = 0;
+  *handle = socket;
+  return 0;
+}
+
+int OPL1000Interface::socket_close(void *handle) {
+  struct opl1000_socket *socket = (struct opl1000_socket *)handle;
+  int err = 0;
+
+  if (!socket) {
+    return NSAPI_ERROR_NO_SOCKET;
+  }
+
+  if (socket->connected && !_esp.close(socket->id)) {
+    err = NSAPI_ERROR_DEVICE_ERROR;
+  }
+
+  if (socket->bound && !_esp.close(socket->id)) {
+    err = NSAPI_ERROR_DEVICE_ERROR;
+  }
+
+  _cbs[socket->id].callback = NULL;
+  _cbs[socket->id].data = NULL;
+  core_util_atomic_store_u8(&_cbs[socket->id].deferred, false);
+
+  socket->connected = false;
+  socket->bound = false;
+  _sock_i[socket->id].open = false;
+  _sock_i[socket->id].sport = 0;
+  delete socket;
+  return err;
+}
+
+int OPL1000Interface::socket_bind(void *handle, const SocketAddress &address) {
+  struct opl1000_socket *socket = (struct opl1000_socket *)handle;
+
+  if (!socket) {
+    return NSAPI_ERROR_NO_SOCKET;
+  }
+  if (socket->proto == NSAPI_UDP) {
+    for (int id = 0; id < OPL1000_SOCKET_COUNT; id++) {
+      if (_sock_i[id].sport == address.get_port() &&
+          id != socket->id) {  // Port already reserved by another socket
+        return NSAPI_ERROR_PARAMETER;
+      } else if (id == socket->id && (socket->connected || socket->bound)) {
+        return NSAPI_ERROR_PARAMETER;
+      }
+    }
+    _sock_i[socket->id].sport = address.get_port();
+
+    int ret = _esp.open_udp(socket->id, address.get_ip_address(),
+                            address.get_port(), _sock_i[socket->id].sport, 2);
+    socket->bound = (ret == NSAPI_ERROR_OK) ? true : false;
+
+    return ret;
+  }
+
+  return NSAPI_ERROR_UNSUPPORTED;
+}
+
+int OPL1000Interface::socket_listen(void *handle, int backlog) {
+  return NSAPI_ERROR_UNSUPPORTED;
+}
+
+int OPL1000Interface::socket_connect(void *handle, const SocketAddress &addr) {
+  struct opl1000_socket *socket = (struct opl1000_socket *)handle;
+  nsapi_error_t ret;
+
+  if (!socket) {
+    return NSAPI_ERROR_NO_SOCKET;
+  }
+
+  if (socket->proto == NSAPI_UDP) {
+    ret = _esp.open_udp(socket->id, addr.get_ip_address(), addr.get_port(),
+                        _sock_i[socket->id].sport, 0);
+  } else {
+    ret = _esp.open_tcp(socket->id, addr.get_ip_address(), addr.get_port(),
+                        socket->keepalive);
+  }
+
+  socket->connected = (ret == NSAPI_ERROR_OK) ? true : false;
+
+  return ret;
+}
+
+int OPL1000Interface::socket_accept(void *server, void **socket,
+                                    SocketAddress *addr) {
+  return NSAPI_ERROR_UNSUPPORTED;
+}
+
+int OPL1000Interface::socket_send(void *handle, const void *data,
+                                  unsigned size) {
+  nsapi_size_or_error_t status;
+  struct opl1000_socket *socket = (struct opl1000_socket *)handle;
+  uint8_t expect_false = false;
+  if (!socket) {
+    return NSAPI_ERROR_NO_SOCKET;
+  }
+
+  if (!_sock_i[socket->id].open) {
+    return NSAPI_ERROR_CONNECTION_LOST;
+  }
+
+  if (!size) {
+    // Firmware limitation
+    return socket->proto == NSAPI_TCP ? 0 : NSAPI_ERROR_UNSUPPORTED;
+  }
+
+  status = _esp.send(socket->id, data, size);
+  if (status == NSAPI_ERROR_WOULD_BLOCK && socket->proto == NSAPI_TCP &&
+      core_util_atomic_cas_u8(&_cbs[socket->id].deferred, &expect_false,
+                              true)) {
+    tr_debug("socket_send(...): Postponing SIGIO from the device.");
+    if (!_global_event_queue->call_in(
+            50ms, callback(this, &OPL1000Interface::event_deferred))) {
+      MBED_ERROR(MBED_MAKE_ERROR(MBED_MODULE_DRIVER, MBED_ERROR_CODE_ENOMEM),
+                 "socket_send(): unable to add event to queue. Increase "
+                 "\"events.shared-eventsize\"\n");
+    }
+
+  } else if (status == NSAPI_ERROR_WOULD_BLOCK && socket->proto == NSAPI_UDP) {
+    status = NSAPI_ERROR_DEVICE_ERROR;
+  }
+
+  return status;
+}
+
+int OPL1000Interface::socket_recv(void *handle, void *data, unsigned size) {
+  struct opl1000_socket *socket = (struct opl1000_socket *)handle;
+
+  if (!socket) {
+    return NSAPI_ERROR_NO_SOCKET;
+  }
+
+  if (!_sock_i[socket->id].open) {
+    return NSAPI_ERROR_CONNECTION_LOST;
+  }
+
+  int32_t recv;
+  if (socket->proto == NSAPI_TCP) {
+    recv = _esp.recv_tcp(socket->id, data, size);
+    if (recv <= 0 && recv != NSAPI_ERROR_WOULD_BLOCK) {
+      socket->connected = false;
+    }
+  } else {
+    recv = _esp.recv_udp(socket, data, size);
+  }
+
+  return recv;
+}
+
+int OPL1000Interface::socket_sendto(void *handle, const SocketAddress &addr,
+                                    const void *data, unsigned size) {
+  struct opl1000_socket *socket = (struct opl1000_socket *)handle;
+
+  if (!socket) {
+    return NSAPI_ERROR_NO_SOCKET;
+  }
+
+  if ((strcmp(addr.get_ip_address(), "0.0.0.0") == 0) || !addr.get_port()) {
+    return NSAPI_ERROR_DNS_FAILURE;
+  }
+
+  if (socket->connected && socket->addr != addr) {
+    if (!_esp.close(socket->id)) {
+      return NSAPI_ERROR_DEVICE_ERROR;
+    }
+    socket->connected = false;
+  }
+
+  if (!socket->connected && !socket->bound) {
+    int err = socket_connect(socket, addr);
+    if (err < 0) {
+      return err;
+    }
+    socket->addr = addr;
+  }
+
+  if (socket->bound) {
+    socket->addr = addr;
+  }
+
+  return socket_send(socket, data, size);
+}
+
+int OPL1000Interface::socket_recvfrom(void *handle, SocketAddress *addr,
+                                      void *data, unsigned size) {
+  struct opl1000_socket *socket = (struct opl1000_socket *)handle;
+
+  if (!socket) {
+    return NSAPI_ERROR_NO_SOCKET;
+  }
+
+  int ret = socket_recv(socket, data, size);
+  if (ret >= 0 && addr) {
+    *addr = socket->addr;
+  }
+
+  return ret;
+}
+
+void OPL1000Interface::socket_attach(void *handle, void (*callback)(void *),
+                                     void *data) {
+  struct opl1000_socket *socket = (struct opl1000_socket *)handle;
+  _cbs[socket->id].callback = callback;
+  _cbs[socket->id].data = data;
+}
+
+nsapi_error_t OPL1000Interface::setsockopt(nsapi_socket_t handle, int level,
+                                           int optname, const void *optval,
+                                           unsigned optlen) {
+  struct opl1000_socket *socket = (struct opl1000_socket *)handle;
+
+  if (!optlen) {
+    return NSAPI_ERROR_PARAMETER;
+  } else if (!socket) {
+    return NSAPI_ERROR_NO_SOCKET;
+  }
+
+  if (level == NSAPI_SOCKET && socket->proto == NSAPI_TCP) {
+    switch (optname) {
+      case NSAPI_KEEPALIVE: {
+        if (socket->connected) {  // OPL1000 limitation, keepalive needs to be
+                                  // given before connecting
+          return NSAPI_ERROR_UNSUPPORTED;
+        }
+
+        if (optlen == sizeof(int)) {
+          int secs = *(int *)optval;
+          if (secs >= 0 && secs <= 7200) {
+            socket->keepalive = secs;
+            return NSAPI_ERROR_OK;
+          }
+        }
+        return NSAPI_ERROR_PARAMETER;
+      }
+    }
+  }
+
+  return NSAPI_ERROR_UNSUPPORTED;
+}
+
+nsapi_error_t OPL1000Interface::getsockopt(nsapi_socket_t handle, int level,
+                                           int optname, void *optval,
+                                           unsigned *optlen) {
+  struct opl1000_socket *socket = (struct opl1000_socket *)handle;
+
+  if (!optval || !optlen) {
+    return NSAPI_ERROR_PARAMETER;
+  } else if (!socket) {
+    return NSAPI_ERROR_NO_SOCKET;
+  }
+
+  if (level == NSAPI_SOCKET && socket->proto == NSAPI_TCP) {
+    switch (optname) {
+      case NSAPI_KEEPALIVE: {
+        if (*optlen > sizeof(int)) {
+          *optlen = sizeof(int);
+        }
+        memcpy(optval, &(socket->keepalive), *optlen);
+        return NSAPI_ERROR_OK;
+      }
+    }
+  }
+
+  return NSAPI_ERROR_UNSUPPORTED;
+}
+
+void OPL1000Interface::event() {
+  if (!_oob_event_id) {
+    // Throttles event creation by using arbitrary small delay
+    _oob_event_id = _global_event_queue->call_in(
+        50ms, callback(this, &OPL1000Interface::proc_oob_evnt));
+    if (!_oob_event_id) {
+      MBED_ERROR(MBED_MAKE_ERROR(MBED_MODULE_DRIVER, MBED_ERROR_CODE_ENOMEM),
+                 "OPL1000Interface::event(): unable to add event to queue. "
+                 "Increase \"events.shared-eventsize\"\n");
+    }
+  }
+
+  for (int i = 0; i < OPL1000_SOCKET_COUNT; i++) {
+    if (_cbs[i].callback) {
+      _cbs[i].callback(_cbs[i].data);
+    }
+  }
+}
+
+void OPL1000Interface::event_deferred() {
+  for (int i = 0; i < OPL1000_SOCKET_COUNT; i++) {
+    uint8_t expect_true = true;
+    if (core_util_atomic_cas_u8(&_cbs[i].deferred, &expect_true, false) &&
+        _cbs[i].callback) {
+      _cbs[i].callback(_cbs[i].data);
+    }
+  }
+}
+
+void OPL1000Interface::attach(
+    Callback<void(nsapi_event_t, intptr_t)> status_cb) {
+  _conn_stat_cb = status_cb;
+}
+
+nsapi_connection_status_t OPL1000Interface::get_connection_status() const {
+  return _conn_stat;
+}
+
+#if MBED_CONF_OPL1000_PROVIDE_DEFAULT
+
+WiFiInterface *WiFiInterface::get_default_instance() {
+  static OPL1000Interface esp;
+  return &esp;
+}
+
+#endif
+
+void OPL1000Interface::refresh_conn_state_cb() {
+  nsapi_connection_status_t prev_stat = _conn_stat;
+  _conn_stat = _esp.connection_status();
+
+  switch (_conn_stat) {
+    // Doesn't require changes
+    case NSAPI_STATUS_CONNECTING:
+    case NSAPI_STATUS_GLOBAL_UP:
+      if (_software_conn_stat == IFACE_STATUS_DISCONNECTED) {
+        _software_conn_stat = IFACE_STATUS_CONNECTED;
+      }
+      break;
+    // Start from scratch if connection drops/is dropped
+    case NSAPI_STATUS_DISCONNECTED:
+      if (_software_conn_stat == IFACE_STATUS_CONNECTED) {
+        _software_conn_stat = IFACE_STATUS_DISCONNECTED;
+      }
+      break;
+    // Handled on AT layer
+    case NSAPI_STATUS_LOCAL_UP:
+    case NSAPI_STATUS_ERROR_UNSUPPORTED:
+    default:
+      _initialized = false;
+      _conn_stat = NSAPI_STATUS_DISCONNECTED;
+      for (int i = 0; i < OPL1000_SOCKET_COUNT; i++) {
+        _sock_i[i].open = false;
+        _sock_i[i].sport = 0;
+      }
+  }
+
+  if (prev_stat == _conn_stat) {
+    return;
+  }
+  tr_debug("refresh_conn_state_cb(): Changed to %d.", _conn_stat);
+
+  if (_conn_stat_cb) {
+    // _conn_stat_cb will be called in _connect_async or disconnect_assync to
+    // avoid race condition
+    if ((_software_conn_stat == IFACE_STATUS_CONNECTING ||
+         _software_conn_stat == IFACE_STATUS_DISCONNECTING) &&
+        (_conn_stat != NSAPI_STATUS_CONNECTING)) {
+      return;
+    }
+
+    _conn_stat_cb(NSAPI_EVENT_CONNECTION_STATUS_CHANGE, _conn_stat);
+  }
+}
+
+void OPL1000Interface::proc_oob_evnt() {
+  _oob_event_id = 0;  // Allows creation of a new event
+  _esp.bg_process_oob(OPL1000_RECV_TIMEOUT, true);
+}
+
+nsapi_error_t OPL1000Interface::_conn_status_to_error() {
+  nsapi_error_t ret;
+
+  switch (_conn_stat) {
+    case NSAPI_STATUS_DISCONNECTED:
+      ret = NSAPI_ERROR_NO_CONNECTION;
+      break;
+    case NSAPI_STATUS_CONNECTING:
+      ret = NSAPI_ERROR_ALREADY;
+      break;
+    case NSAPI_STATUS_GLOBAL_UP:
+      ret = NSAPI_ERROR_IS_CONNECTED;
+      break;
+    default:
+      ret = NSAPI_ERROR_DEVICE_ERROR;
+  }
+
+  return ret;
+}
+
+nsapi_error_t OPL1000Interface::set_blocking(bool blocking) {
+  _if_blocking = blocking;
+
+  return NSAPI_ERROR_OK;
+}
+
+nsapi_error_t OPL1000Interface::set_country_code(bool track_ap,
+                                                 const char *country_code,
+                                                 int len, int channel_start,
+                                                 int channels) {
+  for (int i = 0; i < len; i++) {
+    // Validation done by firmware
+    if (!country_code[i]) {
+      tr_warning("set_country_code(): Invalid country code.");
+      return NSAPI_ERROR_PARAMETER;
+    }
+  }
+
+  _ch_info.track_ap = track_ap;
+
+  // Firmware takes only first three characters
+  strncpy(_ch_info.country_code, country_code, sizeof(_ch_info.country_code));
+  _ch_info.country_code[sizeof(_ch_info.country_code) - 1] = '\0';
+
+  _ch_info.channel_start = channel_start;
+  _ch_info.channels = channels;
+
+  return NSAPI_ERROR_OK;
+}
+
+#endif
diff --git a/connectivity/drivers/wifi/opl1000-driver/OPL1000Interface.h b/connectivity/drivers/wifi/opl1000-driver/OPL1000Interface.h
new file mode 100644
index 0000000000..7ad41a263f
--- /dev/null
+++ b/connectivity/drivers/wifi/opl1000-driver/OPL1000Interface.h
@@ -0,0 +1,548 @@
+/* OPL1000 implementation of NetworkInterfaceAPI refrerence from esp8266-driver.
+ */
+
+#ifndef OPL1000_INTERFACE_H
+#define OPL1000_INTERFACE_H
+
+#if DEVICE_SERIAL && DEVICE_INTERRUPTIN &&                                   \
+    defined(MBED_CONF_EVENTS_PRESENT) && defined(MBED_CONF_NSAPI_PRESENT) && \
+    defined(MBED_CONF_RTOS_API_PRESENT)
+#include "OPL1000/OPL1000.h"
+#include "drivers/DigitalOut.h"
+#include "drivers/Timer.h"
+#include "events/EventQueue.h"
+#include "events/mbed_shared_queues.h"
+#include "netsocket/NetworkInterface.h"
+#include "netsocket/NetworkStack.h"
+#include "netsocket/SocketAddress.h"
+#include "netsocket/WiFiAccessPoint.h"
+#include "netsocket/WiFiInterface.h"
+#include "netsocket/nsapi_types.h"
+#include "platform/Callback.h"
+#include "platform/mbed_chrono.h"
+#if MBED_CONF_RTOS_PRESENT
+#include "rtos/ConditionVariable.h"
+#endif
+#include "rtos/Mutex.h"
+
+#define OPL1000_SOCKET_COUNT 5
+
+#define OPL1000_INTERFACE_CONNECT_INTERVAL 5s
+#define OPL1000_INTERFACE_CONNECT_TIMEOUT \
+  (2 * OPL1000_CONNECT_TIMEOUT + OPL1000_INTERFACE_CONNECT_INTERVAL)
+
+#ifdef TARGET_FF_ARDUINO
+#ifndef MBED_CONF_OPL1000_TX
+#define MBED_CONF_OPL1000_TX D1
+#endif
+
+#ifndef MBED_CONF_OPL1000_RX
+#define MBED_CONF_OPL1000_RX D0
+#endif
+#endif /* TARGET_FF_ARDUINO */
+
+#ifndef MBED_CONF_OPL1000_COUNTRY_CODE
+#define MBED_CONF_OPL1000_COUNTRY_CODE "CN"
+#endif
+
+#ifndef MBED_CONF_OPL1000_CHANNEL_START
+#define MBED_CONF_OPL1000_CHANNEL_START 1
+#endif
+
+#ifndef MBED_CONF_OPL1000_CHANNELS
+#define MBED_CONF_OPL1000_CHANNELS 13
+#endif
+
+/** OPL1000Interface class
+ *  Implementation of the NetworkStack for the OPL1000
+ */
+class OPL1000Interface : public NetworkStack, public WiFiInterface {
+ public:
+#if defined MBED_CONF_OPL1000_TX && defined MBED_CONF_OPL1000_RX
+  /**
+   * @brief OPL1000Interface default constructor
+   *        Will use values defined in mbed_lib.json
+   */
+  OPL1000Interface();
+#endif
+
+  /** OPL1000Interface lifetime
+   * @param tx        TX pin
+   * @param rx        RX pin
+   * @param debug     Enable debugging
+   */
+  OPL1000Interface(PinName tx, PinName rx, bool debug = false, PinName rts = NC,
+                   PinName cts = NC, PinName rst = NC, PinName pwr = NC);
+
+  /**
+   * @brief OPL1000Interface default destructor
+   */
+  virtual ~OPL1000Interface();
+
+  /** Start the interface
+   *
+   *  Attempts to connect to a WiFi network. Requires ssid and passphrase to be
+   * set. If passphrase is invalid, NSAPI_ERROR_AUTH_ERROR is returned.
+   *
+   *  @return         0 on success, negative error code on failure
+   */
+  virtual int connect();
+
+  /** Start the interface
+   *
+   *  Attempts to connect to a WiFi network.
+   *
+   *  If interface is configured blocking it will timeout after up to
+   *  OPL1000_INTERFACE_CONNECT_TIMEOUT_MS + OPL1000_CONNECT_TIMEOUT ms.
+   *
+   *  @param ssid      Name of the network to connect to
+   *  @param pass      Security passphrase to connect to the network
+   *  @param security  Type of encryption for connection (Default:
+   * NSAPI_SECURITY_NONE)
+   *  @param channel   This parameter is not supported, setting it to anything
+   * else than 0 will result in NSAPI_ERROR_UNSUPPORTED
+   *  @return          0 on success, or error code on failure
+   */
+  virtual int connect(const char *ssid, const char *pass,
+                      nsapi_security_t security = NSAPI_SECURITY_NONE,
+                      uint8_t channel = 0);
+
+  /** Set the WiFi network credentials
+   *
+   *  @param ssid      Name of the network to connect to
+   *  @param pass      Security passphrase to connect to the network
+   *  @param security  Type of encryption for connection
+   *                   (defaults to NSAPI_SECURITY_NONE)
+   *  @return          0 on success, or error code on failure
+   */
+  virtual int set_credentials(const char *ssid, const char *pass,
+                              nsapi_security_t security = NSAPI_SECURITY_NONE);
+
+  /** Set the WiFi network channel - NOT SUPPORTED
+   *
+   * This function is not supported and will return NSAPI_ERROR_UNSUPPORTED
+   *
+   *  @param channel   Channel on which the connection is to be made, or 0 for
+   * any (Default: 0)
+   *  @return          Not supported, returns NSAPI_ERROR_UNSUPPORTED
+   */
+  virtual int set_channel(uint8_t channel);
+
+  /** @copydoc NetworkInterface::set_network */
+  virtual nsapi_error_t set_network(const SocketAddress &ip_address,
+                                    const SocketAddress &netmask,
+                                    const SocketAddress &gateway);
+
+  /** @copydoc NetworkInterface::dhcp */
+  virtual nsapi_error_t set_dhcp(bool dhcp);
+
+  /** Stop the interface
+   *  @return             0 on success, negative on failure
+   */
+  virtual int disconnect();
+
+  /** Get the internally stored IP address
+   *  @return             IP address of the interface or null if not yet
+   * connected
+   */
+  virtual nsapi_error_t get_ip_address(SocketAddress *address);
+
+  /** Get the internally stored MAC address
+   *  @return             MAC address of the interface
+   */
+  virtual const char *get_mac_address();
+
+  /** Get the local gateway
+   *
+   *  @return         Null-terminated representation of the local gateway
+   *                  or null if no network mask has been recieved
+   */
+  virtual nsapi_error_t get_gateway(SocketAddress *address);
+
+  MBED_DEPRECATED_SINCE("mbed-os-5.15", "String-based APIs are deprecated")
+  virtual const char *get_gateway();
+
+  /** Get the local network mask
+   *
+   *  @return         Null-terminated representation of the local network mask
+   *                  or null if no network mask has been recieved
+   */
+  virtual nsapi_error_t get_netmask(SocketAddress *address);
+
+  MBED_DEPRECATED_SINCE("mbed-os-5.15", "String-based APIs are deprecated")
+  virtual const char *get_netmask();
+
+  /** Get the network interface name
+   *
+   *  @return         Null-terminated representation of the network interface
+   * name or null if interface not exists
+   */
+  virtual char *get_interface_name(char *interface_name);
+
+  /** Gets the current radio signal strength for active connection
+   *
+   * @return          Connection strength in dBm (negative value)
+   */
+  virtual int8_t get_rssi();
+
+  /** Scan mode
+   */
+  enum scan_mode {
+    SCANMODE_ACTIVE, /*!< active mode */
+    SCANMODE_PASSIVE /*!< passive mode */
+  };
+
+  /** Scan for available networks
+   *
+   * This function will block.
+   *
+   * @param  ap    Pointer to allocated array to store discovered AP
+   * @param  count Size of allocated @a res array, or 0 to only count available
+   * AP
+   * @return       Number of entries in @a, or if @a count was 0 number of
+   * available networks, negative on error see @a nsapi_error
+   */
+  virtual int scan(WiFiAccessPoint *res, unsigned count);
+
+  /** Scan for available networks
+   *
+   * This function will block.
+   *
+   * @param  ap    Pointer to allocated array to store discovered AP
+   * @param  count Size of allocated @a res array, or 0 to only count available
+   * AP
+   * @param  t_max Scan time for each channel - 0-1500ms. If 0 - uses default
+   * value
+   * @param  t_min Minimum for each channel in active mode - 0-1500ms. If 0 -
+   * uses default value. Omit in passive mode
+   * @return       Number of entries in @a, or if @a count was 0 number of
+   * available networks, negative on error see @a nsapi_error
+   */
+  virtual int scan(
+      WiFiAccessPoint *res, unsigned count, scan_mode mode = SCANMODE_PASSIVE,
+      mbed::chrono::milliseconds_u32 t_max = mbed::chrono::milliseconds_u32(0),
+      mbed::chrono::milliseconds_u32 t_min = mbed::chrono::milliseconds_u32(0));
+
+  /** Translates a hostname to an IP address with specific version
+   *
+   *  The hostname may be either a domain name or an IP address. If the
+   *  hostname is an IP address, no network transactions will be performed.
+   *
+   *  If no stack-specific DNS resolution is provided, the hostname
+   *  will be resolve using a UDP socket on the stack.
+   *
+   *  @param address  Destination for the host SocketAddress
+   *  @param host     Hostname to resolve
+   *  @param version  IP version of address to resolve, NSAPI_UNSPEC indicates
+   *                  version is chosen by the stack (defaults to NSAPI_UNSPEC)
+   *  @return         0 on success, negative error code on failure
+   */
+#if MBED_CONF_OPL1000_BUILT_IN_DNS
+  nsapi_error_t gethostbyname(const char *name, SocketAddress *address,
+                              nsapi_version_t version,
+                              const char *interface_name);
+#else
+  using NetworkInterface::gethostbyname;
+#endif
+
+  using NetworkInterface::gethostbyname_async;
+  using NetworkInterface::gethostbyname_async_cancel;
+
+  /** Add a domain name server to list of servers to query
+   *
+   *  @param addr     Destination for the host address
+   *  @return         0 on success, negative error code on failure
+   */
+#if MBED_CONF_OPL1000_BUILT_IN_DNS
+  nsapi_error_t add_dns_server(const SocketAddress &address,
+                               const char *interface_name);
+#else
+  using NetworkInterface::add_dns_server;
+#endif
+
+  /** @copydoc NetworkStack::setsockopt
+   */
+  virtual nsapi_error_t setsockopt(nsapi_socket_t handle, int level,
+                                   int optname, const void *optval,
+                                   unsigned optlen);
+
+  /** @copydoc NetworkStack::getsockopt
+   */
+  virtual nsapi_error_t getsockopt(nsapi_socket_t handle, int level,
+                                   int optname, void *optval, unsigned *optlen);
+
+  /** Register callback for status reporting
+   *
+   *  The specified status callback function will be called on status changes
+   *  on the network. The parameters on the callback are the event type and
+   *  event-type dependent reason parameter.
+   *
+   *  In OPL1000 the callback will be called when processing OOB-messages via
+   *  AT-parser. Do NOT call any OPL1000Interface -functions or do extensive
+   *  processing in the callback.
+   *
+   *  @param status_cb The callback for status changes
+   */
+  virtual void attach(mbed::Callback<void(nsapi_event_t, intptr_t)> status_cb);
+
+  /** Get the connection status
+   *
+   *  @return         The connection status according to ConnectionStatusType
+   */
+  virtual nsapi_connection_status_t get_connection_status() const;
+
+ protected:
+  /** Open a socket
+   *  @param handle       Handle in which to store new socket
+   *  @param proto        Type of socket to open, NSAPI_TCP or NSAPI_UDP
+   *  @return             0 on success, negative on failure
+   */
+  virtual int socket_open(void **handle, nsapi_protocol_t proto);
+
+  /** Close the socket
+   *  @param handle       Socket handle
+   *  @return             0 on success, negative on failure
+   *  @note On failure, any memory associated with the socket must still
+   *        be cleaned up
+   */
+  virtual int socket_close(void *handle);
+
+  /** Bind a server socket to a specific port
+   *  @param handle       Socket handle
+   *  @param address      Local address to listen for incoming connections on
+   *  @return             0 on success, negative on failure.
+   */
+  virtual int socket_bind(void *handle, const SocketAddress &address);
+
+  /** Start listening for incoming connections
+   *  @param handle       Socket handle
+   *  @param backlog      Number of pending connections that can be queued up at
+   * any one time [Default: 1]
+   *  @return             0 on success, negative on failure
+   */
+  virtual int socket_listen(void *handle, int backlog);
+
+  /** Connects this TCP socket to the server
+   *  @param handle       Socket handle
+   *  @param address      SocketAddress to connect to
+   *  @return             0 on success, negative on failure
+   */
+  virtual int socket_connect(void *handle, const SocketAddress &address);
+
+  /** Accept a new connection.
+   *  @param handle       Handle in which to store new socket
+   *  @param server       Socket handle to server to accept from
+   *  @return             0 on success, negative on failure
+   *  @note This call is not-blocking, if this call would block, must
+   *        immediately return NSAPI_ERROR_WOULD_WAIT
+   */
+  virtual int socket_accept(void *handle, void **socket,
+                            SocketAddress *address);
+
+  /** Send data to the remote host
+   *  @param handle       Socket handle
+   *  @param data         The buffer to send to the host
+   *  @param size         The length of the buffer to send
+   *  @return             Number of written bytes on success, negative on
+   * failure
+   *  @note This call is not-blocking, if this call would block, must
+   *        immediately return NSAPI_ERROR_WOULD_WAIT
+   */
+  virtual int socket_send(void *handle, const void *data, unsigned size);
+
+  /** Receive data from the remote host
+   *  @param handle       Socket handle
+   *  @param data         The buffer in which to store the data received from
+   * the host
+   *  @param size         The maximum length of the buffer
+   *  @return             Number of received bytes on success, negative on
+   * failure
+   *  @note This call is not-blocking, if this call would block, must
+   *        immediately return NSAPI_ERROR_WOULD_WAIT
+   */
+  virtual int socket_recv(void *handle, void *data, unsigned size);
+
+  /** Send a packet to a remote endpoint
+   *  @param handle       Socket handle
+   *  @param address      The remote SocketAddress
+   *  @param data         The packet to be sent
+   *  @param size         The length of the packet to be sent
+   *  @return             The number of written bytes on success, negative on
+   * failure
+   *  @note This call is not-blocking, if this call would block, must
+   *        immediately return NSAPI_ERROR_WOULD_WAIT
+   */
+  virtual int socket_sendto(void *handle, const SocketAddress &address,
+                            const void *data, unsigned size);
+
+  /** Receive a packet from a remote endpoint
+   *  @param handle       Socket handle
+   *  @param address      Destination for the remote SocketAddress or null
+   *  @param buffer       The buffer for storing the incoming packet data
+   *                      If a packet is too long to fit in the supplied buffer,
+   *                      excess bytes are discarded
+   *  @param size         The length of the buffer
+   *  @return             The number of received bytes on success, negative on
+   * failure
+   *  @note This call is not-blocking, if this call would block, must
+   *        immediately return NSAPI_ERROR_WOULD_WAIT
+   */
+  virtual int socket_recvfrom(void *handle, SocketAddress *address,
+                              void *buffer, unsigned size);
+
+  /** Register a callback on state change of the socket
+   *  @param handle       Socket handle
+   *  @param callback     Function to call on state change
+   *  @param data         Argument to pass to callback
+   *  @note Callback may be called in an interrupt context.
+   */
+  virtual void socket_attach(void *handle, void (*callback)(void *),
+                             void *data);
+
+  /** Provide access to the NetworkStack object
+   *
+   *  @return The underlying NetworkStack object
+   */
+  virtual NetworkStack *get_stack() { return this; }
+
+  /** Set blocking status of connect() which by default should be blocking.
+   *
+   *  @param blocking Use true to make connect() blocking.
+   *  @return         NSAPI_ERROR_OK on success, negative error code on failure.
+   */
+  virtual nsapi_error_t set_blocking(bool blocking);
+
+  /** Set country code
+   *
+   *  @param track_ap      if TRUE, use country code used by the AP ESP is
+   * connected to, otherwise uses country_code always
+   *  @param country_code  ISO 3166-1 coded, 2 character alphanumeric country
+   * code assumed
+   *  @param len           Length of the country code
+   *  @param channel_start The channel number to start at
+   *  @param channel       Number of channels
+   *  @return              NSAPI_ERROR_OK on success, negative error code on
+   * failure.
+   */
+  nsapi_error_t set_country_code(bool track_ap, const char *country_code,
+                                 int len, int channel_start, int channels);
+
+ private:
+  // AT layer
+  OPL1000 _esp;
+  void refresh_conn_state_cb();
+
+  /** Status of software connection
+   */
+  typedef enum esp_connection_software_status {
+    IFACE_STATUS_DISCONNECTED = 0,
+    IFACE_STATUS_CONNECTING = 1,
+    IFACE_STATUS_CONNECTED = 2,
+    IFACE_STATUS_DISCONNECTING = 3
+  } esp_connection_software_status_t;
+
+  // HW reset pin
+  class ResetPin {
+   public:
+    ResetPin(PinName rst_pin);
+    void rst_assert();
+    void rst_deassert();
+    bool is_connected();
+
+   private:
+    mbed::DigitalOut _rst_pin;
+  } _rst_pin;
+
+  // HW power pin
+  class PowerPin {
+   public:
+    PowerPin(PinName pwr_pin);
+    void power_on();
+    void power_off();
+    bool is_connected();
+
+   private:
+    mbed::DigitalOut _pwr_pin;
+  } _pwr_pin;
+
+  /** Assert the reset and power pins
+   *  OPL1000 has two pins serving similar purpose and this function asserts
+   * them both if they are configured in mbed_app.json.
+   */
+  void _power_off();
+
+  // Credentials
+  static const int OPL1000_SSID_MAX_LENGTH =
+      32; /* 32 is what 802.11 defines as longest possible name */
+  char ap_ssid[OPL1000_SSID_MAX_LENGTH +
+               1]; /* The longest possible name; +1 for the \0 */
+  static const int OPL1000_PASSPHRASE_MAX_LENGTH =
+      63; /* The longest allowed passphrase */
+  static const int OPL1000_PASSPHRASE_MIN_LENGTH =
+      8; /* The shortest allowed passphrase */
+  char ap_pass[OPL1000_PASSPHRASE_MAX_LENGTH +
+               1]; /* The longest possible passphrase; +1 for the \0 */
+  nsapi_security_t _ap_sec;
+
+  // Country code
+  struct _channel_info {
+    bool track_ap;  // Set country code based on the AP ESP is connected to
+    char country_code[4];  // ISO 3166-1 coded, 2-3 character alphanumeric
+                           // country code - +1 for the '\0' - assumed.
+                           // Documentation doesn't tell.
+    int channel_start;
+    int channels;
+  };
+  struct _channel_info _ch_info;
+
+  bool _if_blocking;  // NetworkInterface, blocking or not
+#if MBED_CONF_RTOS_PRESENT
+  rtos::ConditionVariable _if_connected;
+#endif
+
+  // connect status reporting
+  nsapi_error_t _conn_status_to_error();
+  mbed::Timer _conn_timer;
+
+  // Drivers's socket info
+  struct _sock_info {
+    bool open;
+    uint16_t sport;
+  };
+  struct _sock_info _sock_i[OPL1000_SOCKET_COUNT];
+
+  // Driver's state
+  int _initialized;
+  nsapi_error_t _connect_retval;
+  nsapi_error_t _disconnect_retval;
+  bool _get_firmware_ok();
+  nsapi_error_t _init(void);
+  nsapi_error_t _reset();
+
+  // sigio
+  struct {
+    void (*callback)(void *);
+    void *data;
+    uint8_t deferred;
+  } _cbs[OPL1000_SOCKET_COUNT];
+  void event();
+  void event_deferred();
+
+  // Connection state reporting to application
+  nsapi_connection_status_t _conn_stat;
+  mbed::Callback<void(nsapi_event_t, intptr_t)> _conn_stat_cb;
+
+  // Background OOB processing
+  // Use global EventQueue
+  events::EventQueue *_global_event_queue;
+  int _oob_event_id;
+  int _connect_event_id;
+  int _disconnect_event_id;
+  void proc_oob_evnt();
+  void _connect_async();
+  void _disconnect_async();
+  rtos::Mutex _cmutex;  // Protect asynchronous connection logic
+  esp_connection_software_status_t _software_conn_stat;
+};
+#endif
+#endif
diff --git a/connectivity/drivers/wifi/opl1000-driver/mbed_lib.json b/connectivity/drivers/wifi/opl1000-driver/mbed_lib.json
new file mode 100644
index 0000000000..caf7541c54
--- /dev/null
+++ b/connectivity/drivers/wifi/opl1000-driver/mbed_lib.json
@@ -0,0 +1,108 @@
+{
+    "name": "opl1000",
+    "config": {
+        "tx": {
+            "help": "TX pin for serial connection. D1 assumed if Arduino Form Factor, needs to be set/overwritten otherwise",
+            "value": null
+        },
+        "rx": {
+            "help": "RX pin for serial connection. D0 assumed if Arduino Form Factor, needs to be set/overwritten otherwise",
+            "value": null
+        },
+        "rts": {
+            "help": "RTS pin for serial connection, defaults to Not Connected",
+            "value": null
+        },
+        "cts": {
+            "help": "CTS pin for serial connection, defaults to Not Connected",
+            "value": null
+        },
+        "serial-baudrate": {
+            "help": "Serial baudrate for OPL1000, defaults to 115200",
+            "value": 115200
+        },
+        "rst": {
+            "help": "RESET pin for the modem, defaults to Not Connected",
+            "value": null
+        },
+        "pwr": {
+            "help": "POWER pin for the modem, defaults to Not Connected",
+            "value": null
+        },
+        "power-on-polarity": {
+            "help": "Polarity of power-on for the modem. 0 means 0/1 for power on/off; 1 means 1/0 for power on/off.",
+            "options": [0, 1],
+            "value": 0
+        },
+        "power-on-time-ms": {
+            "help": "Delay after powering on the modem in ms",
+            "value": 3
+        },
+        "power-off-time-ms": {
+            "help": "Delay after powering off the modem in ms",
+            "value": 3
+        },
+        "debug": {
+            "help": "Enable debug logs. [true/false]",
+            "value": false
+        },
+        "provide-default": {
+            "help": "Provide default WifiInterface. [true/false]",
+            "value": false
+        },
+        "socket-bufsize": {
+            "help": "Max socket data heap usage",
+            "value": 8192
+        },
+        "country-code": {
+            "help": "ISO 3166-1 coded, 2 character alphanumeric country code, 'CN' by default",
+            "value": null
+        },
+        "channel-start": {
+            "help": "The channel number to start at, 1 by default",
+            "value": null
+        },
+        "channels": {
+            "help": "Channel count, 13 by default",
+            "value": null
+        },
+        "built-in-dns": {
+            "help": "use built-in CIPDOMAIN AT command to resolve address to IP",
+            "value": false
+        },
+        "sntp-enable": {
+            "help": "Enable SNTP. This allows application to use get_sntp_time(). Only available from OPL1000 AT v1.5. This driver supports v1.7 and higher.",
+            "value": false
+        },
+        "sntp-timezone": {
+            "help": "SNTP timezone",
+            "value": 0
+        },
+        "sntp-server0": {
+            "help": "First SNTP server. Empty string will let OPL1000 use its default.",
+            "value": "\"\""
+        },
+        "sntp-server1": {
+            "help": "Second SNTP server. Empty string will let OPL1000 use its default.",
+            "value": "\"\""
+        },
+        "sntp-server2": {
+            "help": "Third SNTP server. Empty string will let OPL1000 use its default.",
+            "value": "\"\""
+        }
+    },
+    "target_overrides": {
+         "HEXIWEAR": {
+            "tx": "PTD3",
+            "rx": "PTD2"
+        },
+        "NUCLEO_F401RE": {
+            "tx": "D8",
+            "rx": "D2"
+        },
+        "NUCLEO_F411RE": {
+            "tx": "D8",
+            "rx": "D2"
+        }
+    }
+}
diff --git a/connectivity/netsocket/CMakeLists.txt b/connectivity/netsocket/CMakeLists.txt
index 9760c60316..d9748a1146 100644
--- a/connectivity/netsocket/CMakeLists.txt
+++ b/connectivity/netsocket/CMakeLists.txt
@@ -69,6 +69,7 @@ endif()
 
 target_link_libraries(mbed-netsocket
     INTERFACE
+        mbed-wifi
         mbed-cellular
         mbed-nanostack-libservice
 )
-- 
2.17.1

